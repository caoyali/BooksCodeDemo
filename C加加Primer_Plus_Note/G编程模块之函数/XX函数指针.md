跳着学这个实属无奈啊。写代码的时候用到了， 不知道函数指针是个啥玩意，很是烦恼。主要是这个搞不明白，这期的需求可能会写着有问题。我现在状态非常差，感觉丢了魂一样。所以我打算直接照着书抄了。希望渐入佳境。

# 函数指针
如果未提到函数指针，则对C或者C++的讨论将是不完整的。我们将大致介绍一下这个主题，将完整的介绍留给更高级的图书。
与数据项相似，函数也有地址。函数的地址是，存储其及其语言代码的开始地址。通常，这些地址对于用户而言，既不重要，也没什么用处。但是对于程序而言，却很有用。 例如： 可以编写将另一个函数的地址作为参数的函数。这样第一个函数就能找到第二个函数，并运行它。与直接调用另一个函数相比，这种方法很笨拙，反式它允许在不同的时间传递不同的函数的地址，这以为着可以在不同的时间使用不同的函数。 这个角度也真特么清奇。这书说实话我看了就困。我不知道是作者写的跟我气场不和还是翻译的跟我气场不和。反正看起来特别容易犯困，而且感觉不容易理解， 满篇不知道作者在讲啥！

## 函数指针的基础知识
首先通过一个例子阐释这一过程。假设我们要设计一个名为estimate()的函数，估算编写指定行数的代码所需的时间，并希望程序员都使用这个函数。对于所有用户来讲estimate()中一部分代码都是相同的，但是该函数允许每个程序员提供自己的算法来估算时间。为实现这种目标，采用的机制是，将程序员要使用的算法函数的地址传递给eatimate()。 为此，必须能够完成下面的工作:
- 获取函数指针
- 声明一个函数指针
- 使用函数指针来调用函数

**获取函数的地址**
获取函数的地址特别简单，只需要使用函数名(后面不跟参数)即可。也就是说，如果think()是一个函数，则think就是该函数的地址。要将函数作为参数进行传递的话，必须取的是函数名。一定要区分，传递的到底是函数的地址，还是函数的返回值。
区分到底给的是函数地址，还是函数的返回值。也正是我们给进函数指针的时候给函数名的原因。因为这样才能和 函数的返回值 这种情况做出区分。否则你咋区分？
```java
process(think);     // passes address of think() to process()
thought(think());   // passes return value of think() to thought()
```
区别：
process()调用使得process函数能在其内部调用think()函数。 thought()调用首先调用think()函数，然后将think()的返回值传递给thought()函数。

**声明函数指针**
声明指向某种数据类型的指针时，必须指定指针指向的类型。同样，声明指向函数的指针时，也必须指定指针指向的函数类型。这意味着声明应指定函数的返回类型以及函数的特征标(参数列表)。也就是说，声明应像函数原型那样指出有关函数的信息。例如，假设pam lecoder编写了一个估算时间的函数，其原型如下：
double pam(int);
则正确的指针类型声明如下：
double (*pf)(int);  
1 这里面的原型和声明是什么区别啊， 是不是既要有原型又要有声明

这与pam()声明类似，这是将pam替换为了(*pf)。由于pam是函数，因此(*pf)也是函数，(这特么什么屁理解逻辑啊！没有因果关系，只是根据事实强推的啊。)。而如果（*pf）是函数，则 pf就是函数指针。
**提示**： 通常，要生命指向特定类型的函数的指针，可以首先编写这种函数的原型，然后用(*pf)替换函数名。这样pf就是这类函数的指针。
为提供正确的运算符优先级，必须在声明中使用括号将*pf括起来。括号的优先级比*的运算符优先级要高， 因此，*pf(int)意味着pf()是一个返回指针的函数， 而（*pf）(int)意味着是一个指向函数的指针。这个是有区别的。记得别写错。
正确地声明pf后，便可以将相应的函数地址赋给它， 我靠怎么还有这一步
```c++
double pam(int);
double (*pf) (int);

pf = pam;     //now pf points to the pam() function
```
注意， pam 的特征标必须与pf相同。如果不相同，编译期将拒绝这样的赋值。
下面是错误示范：
```C++
double ned(double);
int ted(int);
double (*pf) (int);

pf = ted; //错，因为返回值不一样 
pf = ned; //错，因为参数列表不一样
```
现在回过头来看一下前面提到的estimeate()函数，假设要将将编写的代码行数和估算算法(如pam()函数)的地址传递给它，其原型将如下：
```c++
void estimate(int lines, double (*pf)(int));
```
上述声明指出，第二个参数是一个指针函数，它指向的函数接受一个int参数，并返回一个double值。要让estimate()使用pam函数，需要将pam的地址传递给它：
```c++
estimate(50, pam); //function call telling estimate() to use pam()
```
显然，使用函数指针时，比较棘手的就是编写原型，而传递地址则是很简单的。

**使用指针来调用函数**
现在进入最后一步，即使使用指针来调用被指向的函数。线索来自指针声明。前面讲过，(*pf)扮演的角色与函数名相同，因此使用(*pf)时，只需要将它看做函数名即可。 将指针名看成函数名哈！这个别忘了！
```c++
double pam(int);
double (*pt)(int);
pt = pam;
double x = pam(4);
double y = (*pt)(5);  //为什么这个带星号啊！好吧，就看成是整个替换了！
// 实际上，C++也允许像使用函数名那样使用pf
double y = pf(5); //also call pam() using the pointer pf
// 第一种格式虽然不是很好看，但是它给出了强有力的提示，代码正在使用函数指针。
```
**历史与逻辑**
真是个非常棒的语法！为何pf和(*pf)等价呢？一种学派认为，由于pf是函数指针，而*pf是函数，因此将(*pf)()用作函数调用。另一种学派认为，由于函数名是指向该函数的指针，指向函数的指针的行为应与函数名相似，因此应将pf()用作函数调用的使用。C++进行了折中--这两种方式是正确的，或者至少是允许的，虽然他们的逻辑上是互相冲突的。在认为这种折中粗糙之前，应该想到，容忍逻辑上无法自圆其说的观点是人类思维活动的特点。

## 函数指针示例

```c++
// fun_ptr.cpp --pointer to functions
#include <iostream>
double betsy(int);
double pam(int);

void estimate(int lines, double (*pf)(int));

int main(){
    using namespace std;
    int code;
    cout << "How many lines of code do you need? ";
    cin >> code;
    cout << "Here's Betsy's estimate: \n";
    estimate(code, betsy);
    cout << "Here's Pam's estimate: \n";
    estimate(code, pam);
    return 0;
}

double betsy(int lns) {
    return 0.05 * lns;
}

double pam(int lns) {
    return 0.03 * lns + 0.0004 * lns + lns;
}

void estimate(int lines, double (*pt)(int)) {
    using namespace std;
    cout << lines << " lines will take ";
    cout << (*pt)(lines) << " hour(s)\n"; // 看着点，这块是这么调用的！
}
```
上述程序清单7.18演示了如何使用函数指针。它两次调用了estimate()函数，一次传递betsy()函数的地址，另一次则是传递pam()函数的地址。在第一种情况下，estimate()使用besty()计算所需的小时数：在第二种情况下，estimate()使用pam()进行计算。这种设计有助于今后的程序开发。当Ralph为估算时间而开发自己的算法时，将不需要重新编写estimate()。相反，他只需要提供自己的ralph()函数，并确保该函数的特征标和返回类型正确即可。当然，重新编写estimate()也并不是一件非常困难的工作，但同样的原则也使用汉语更加复杂的代码。另外，函数指针方式使得Palph能够修改estimate()的行为，虽然他接触不到estimate()的源代码。

## 深入讨论函数指针
函数指针的表示可能非常恐怖。下面通过一个示例演示使用函数指针时的一些挑战。首先，下面是一些函数的原型，他们的特征标和返回类型相同：
```c++
const double *f1(const double ar[], int n);
const double *f2(const double[], int);
const double *f3(const double *, int);
```
这些函数的特征标看似不同，但实际上相同。首先，前面说过，在函数原型中，参数列表 const double ar[] 与 const double *ar 的含义完全相同。其次，在函数原型中，可以 省略标识符。因此， const double ar[] 可以简化为 const double[], 而 const double *ar 也可以简化为 const double *。因此，上述所有函数特征标的含义都相同。另一方面，函数定义必须提供标识符，因此需要使用 const double ar[], 或者const double *ar。

接下来，假设要生命一个指针，它可指向这三个函数之一。假设该指针名为pa， 则只需要将目标函数原型中的函数名替换为(*pa):
```c++
const double * (*p1) (const double *, int);
// 可在声明的同时进行初始化
const double* (*p1) (const double*, int) = f1;
// 使用C++11的自动类型推断功能时，代码要简单的多：
auto p1 = f1; // C++11 automatic type deduction.
// 现在来看下面的语句
 cout << (*p1)(av, 3) << " : " << *(*p1)(av, 3) << endl;
 cout << p2(av, 3) << " : " << *p2(av, 3) << endl;   //都一样
 ```
 根据前面介绍的知识可以知道，(*p1)(av, 3) 和 p2(av, 3)都调用指向的函数， （这里为f1()和 f2()）,并将av和3作为参数。 因此，显示的是这两个函数的返回值。返回值的类型为 const double* （及double的值的地址）， 因此在每条cout语句中，前半部分显示的都是一个double值的地址。为查看存储在这个地址处的实际值，需要将运算符*应用于这些地址。如表达式*(*p1)(av, 3) 和 *拍（AV， 3）所示。
 鉴于需要使用三个函数，如果有一个函数指针数组将很方便。这样，将可使用for循环通过指针依次调用每个函数。如何声明这样的数组呢？显然，这种声明应类似于单个函数指针的声明，但必须在某个地方加上[3],以指出这是一个包含三个函数指针的数组。问题是在什么地方加上[3],答案如下(包含初始化)：
 ```c++
 const double* (*pa[3]) (const double*, int) = {f1, f2, f3};
 ```
 为何将[3]放到这个位置呢？pa是一个包含三个元素的数组，而要生命这样的数组，首先要使用pa[3]。该声明的其他部分指出了数组包含的元素是什么样子的。运算符[]的优先级高于*， 因此*pa[3]表明pa是一个包含三个指针的数组。上述声明的其他部分指出了每个指针指向的是什么。 特征标为const double*, int, 且返回类型是const double* 的函数。因此pa是一个包含三个指针的数组。其中每个指针都指向这样的函数。即将 const double* 和 int作为参数，并返回一个const double* 。

这里能否使用auto呢？不能！自动类型推断只能适用于单值的初始化，而不能用于初始化一个列表。但声明数组pa后，声明同样类型的数组就很简单了。
```c++
auto pb = pa;
```

## 感谢auto
C++11的目标之一就是让C++更容易使用，从而让程序员将主要精力放在设计上而不是细节上。程序清单7.19演示了这一点。
以下这两行代码功能是一样的，区别是一个是c++11 语法，一个是老的
```c++
auto pc = &pa;
const double* (*(*pd)[3]) (const double*, int) = &pa;
```
自动推断功能表明，编译器的角色发生了改变， 在C++98中，编译器利用其只是帮助我们发现错误，而在C++11中么，编译器利用其知识帮助我们进行正确的声明。
存在一个潜在的缺点就是，自动推断类型确保变量的类型与赋予它的初始值的类型一致，但提供的初始值的类型可能是不对的。

