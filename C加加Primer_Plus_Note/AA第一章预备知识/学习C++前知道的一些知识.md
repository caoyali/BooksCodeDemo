# 编程方式
- 面向过程编程
- 面向对象编程
- 泛型编程
  
结构化编程--将一些语句搞成结构化的，例如if else， while等，没有这个之前，你记不记得汇编里面的jump这个鬼，累死个人。
但是人家遵循一个设计原则:自顶向下设计原则--将大程序拆成小程序
面向过程实际上着重的是算法。

面向对象编程的本质是，面向数据编程，把遇到的所有问题抽象成与之对应的数据。着重数据。![Snipaste_2021-10-19_18-56-47](/assets/Snipaste_2021-10-19_18-56-47.png)![Snipaste_2021-10-19_19-01-18](/assets/Snipaste_2021-10-19_19-01-18.png)

# include是个啥
```c++
# include <iostream> //# include是给预处理程序用的,后期会把所有代码都加到该文件中。想象你写汇编的时候不就是有很多复制粘贴的相同逻辑，位于不同的文件里面么，这个同理。
using namespace std; 
```
# 头文件名字
C的头文件叫.h 但是C++不一样，它兼容了C但是对于他自己却保有了自己的一套，C++的头文件没有扩展名。有的C头文件转成了C++的头文件，会在文件的名字前面加上c前缀，以表明这个家伙是c语言的头文件变过来的。但是他们依然没有格式(扩展名)，对没有任何格式符号！
这也就是你经常疑惑的一点的答案，就是为什么有这样的代码
```c++
# include "somename.h"
# include <iostream>  //预处理文件名字不一样。与C++的发展历史有关系
```
# 名称空间

```C++
using namespace std; //这句话拆析
```
- using，是是一个编译指令，注意是编译！！！！我们之前血的那个include是预处理指令，不要搞混了！
  
**命名空间最初是怎么用的？**
命名空间最初的时候是不同的代码厂商用的，首先，一家代码厂商或许会写上几百上千个源代码文件，那文件的名字，尤其是里面函数的名字多了去了！
对于开发人员，很可能会引入不同的厂商的代码一块进行使用。 
那么如果两个厂商都写了同一个名字的函数，如果你直接调用，编译器就直接不知道要调哪个函数了，到底是什么厂商的，没有一个区分唯一的办法。于是就有了命名空间这个东西。由字及意，仔细想想就能明白了（作为一个写java的，我觉得这种方式真是太low了！）， 比如两家公司一家叫aaaa，一家叫bbbb，他们的命名空间很可能会带上这些具有区分意义的字符，让开发人员明白。

你要是不写那个 using namespace std会怎么样呢？
```C++
std::cout << "Come up C++ me some time";
std::cout << std :: endl;//每句都加上，能确保调到的代码是唯一精准的。但是这样写是不是很麻烦！
```
using 关键字就是为了解决这种麻烦的。
我此时还有个疑惑呢！万一就算是同一家公司，同一个命名空间下也有名字冲突的方法呢？此时怎么办？