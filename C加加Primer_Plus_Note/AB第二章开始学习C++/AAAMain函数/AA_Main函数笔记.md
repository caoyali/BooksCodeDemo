# 通过main函数认识
- 注释是什么
- 预处理语句
- 函数头
- 方法体
- 编译指令
- return

## main（）函数
将[AA_MyFirst.cpp](C加加Primer_Plus_Note/AB第二章开始学习C++/AAAMain函数/AA_MyFirst.cpp)的例子，拿出来，简化所有的步骤最终得到的是
```c++
int main() // 返回值 + 函数是干嘛的 + 如果需要的话，括号里面可能有参数。 在C语言中，返回类型不写的话，默认返回int。 但是这样感觉有点二。
{
    方法体；
    return 0；
}
```
- 通常，main（）函数是被启动代码调用，而启动代码是由编译器添加到程序中的，main方法是程序和操作系统之间的桥梁。
- 经典的C语言的main方法，可以这样写   main()  没有明确的返回值，说明默认返回的是int，但是在C++里逐步淘汰了这种做法。由于历史上的原因，main函数尽量写成 带返回值的，其实也是允许写成不带返回值的那种，但是，前面说了，有历史原因，因为古老的代码都默认调用带返回值的那种，你的代码要是不带返回值，不保证万无一失哈！
- main函数还有一个特殊的点是，有些人觉得写return 0 很麻烦，ANSI/ISO C++ 针对此做出了妥协，如果人们不写return 0之类的， 编译器自动认为会返回，仅仅针对main函数啊，其余的函数甭想这么偷懒！还记得前些日子碰到的一些开启app就崩溃的那种问题，就是某些函数中没有写返回值，也不知道为啥，编译器也通过了，然后打开app就崩溃，搞的很多人崩溃了好几天！
- C++程序是必须包含一个main函数的。 如果你发现你所做的项目里面没有main函数，那么好好捋捋源头，肯定有被封装的一处，是调用main方法的地方，只不过他们是以一种方式封装了而已
  

分清什么是语句，以什么为结尾，很显然是分号。分号是C++里面的终止符。
在这里，回顾几个人尽皆知的概念：

# 预处理语句  # include
有一种预处理器，是专门处理这种带有井号的代码，并且它的工作内容就是将被 include 的文件的内容全部添加到程序中去，很粗暴，就是替换或者添加文本！
```c++
# include "somename.h"
# include <iostream>
```

# 头文件名字
C的头文件叫.h 但是C++不一样，它兼容了C但是对于他自己却保有了自己的一套，C++的头文件没有扩展名。有的C头文件转成了C++的头文件，会在文件的名字前面加上c前缀，以表明这个家伙是c语言的头文件变过来的。但是他们依然没有格式(扩展名)，对没有任何格式符号！
这也就是你经常疑惑的一点的答案，就是为什么有这样的代码
```c++
# include "somename.h"
# include <iostream>  //预处理文件名字不一样。与C++的发展历史有关系
```
# 名称空间

```C++
using namespace std; //这句话拆析
```
- using，是是一个编译指令，注意是编译！！！！我们之前血的那个include是预处理指令，不要搞混了！
  
**命名空间最初是怎么用的？**
命名空间最初的时候是不同的代码厂商用的，首先，一家代码厂商或许会写上几百上千个源代码文件，那文件的名字，尤其是里面函数的名字多了去了！
对于开发人员，很可能会引入不同的厂商的代码一块进行使用。 
那么如果两个厂商都写了同一个名字的函数，如果你直接调用，编译器就直接不知道要调哪个函数了，到底是什么厂商的，没有一个区分唯一的办法。于是就有了命名空间这个东西。由字及意，仔细想想就能明白了（作为一个写java的，我觉得这种方式真是太low了！）， 比如两家公司一家叫aaaa，一家叫bbbb，他们的命名空间很可能会带上这些具有区分意义的字符，让开发人员明白。

你要是不写那个 using namespace std会怎么样呢？
```C++
std::cout << "Come up C++ me some time";
std::cout << std :: endl;//每句都加上，能确保调到的代码是唯一精准的。但是这样写是不是很麻烦！
```
using 关键字就是为了解决这种麻烦的。
我此时还有个疑惑呢！万一就算是同一家公司，同一个命名空间下也有名字冲突的方法呢？此时怎么办？


