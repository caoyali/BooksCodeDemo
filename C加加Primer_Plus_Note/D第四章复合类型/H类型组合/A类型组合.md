# 类型组合
本章主要介绍了数组，结构，和指针。可以以各种方式组合他们。

```C++
struct antarctica_years_end{
    int year;
}

// 可以创建这样的变量
antarctica_years_end s01, s02, s03;

s01.year = 1993;

antarctica_years_end* pa = &s02;
pa -> year = 1990;


// 数组，我们知道 tiro[0] 是第0个，[1]是第一个， 但是，tiro是个啥呢？书上说tiro本身是一个指针！
antarctica_years_end tiro[3];
tiro[0].year = 2003;
(tiro + 1) -> year = 2004; //正因为tiro是一个指针，所以这个加上1 其地址自然而言指向的就是下一个位置。

// 指针数组，这块有点绕脑哈！ 指针数组里面存储的全是指针!!!你一定要记住这个呀
const antarctica_years_end *arp[3] = {&s01, &s02, &s03}    
std::cout << arp[1] -> year << std::endl;

// 这块似乎就更烧脑了！
//耐心把这个arp解开了理解! arp本身是一个指针啊！  arp里面存储的也是指针！arp也就意味着 arp[0]这个位置，但是这个里面存储的就是指针，我们声明的时候就是这么讲的！来来回回是有两层的，也就是指针的指针！
// 我们得扒开来看，双向解释，首先 **ppa 这个家伙!  首先它是一个指针！指针里面存储的内容呢，又是一个指针！
// 再看这个 const antarctica_years_end *arp[3] = {&s01, &s02, &s03}   arp已经被声明是一个指针数组了，理念存储的就是指针，而数组名字本身就是一个指针，也就是指针的指针
const antarctica_years_end **ppa = arp;
```
个人理解，区分 [index] 与 (point + index) -> 变量。
对于数组而言，我们一定要记住一个事情，就是，**数组名本身就是一个指针！！！**
而上方我们为什么可以  point[index] 就能引用到具体的索引去做事情，是因为编译器为了方便我们调用代码，人家给做了处理。毕竟是能提高效率的事情，做了总归是好事。这点所有人都可以理解的。
那么为什么 (point + index) -> 变量。 这种，index也能找到合适的内存去用呢？  原因是， C++里面**如果我们对一个变量没有加任何操作，人家默认就是值引用，取值来用！** point的值是啥呢？？？地址呀！！！地址加了index，，C++原本就知道这家伙是什么类型的，加了个index， 人家内部知道最终给加成了几，很简单么，你什么类型我就把占用内存给计算上不就很容易知道酒精加几了么？所以也能引到的。

# 个人归纳
我觉的这块，我们有必要暂停手头所有学习进度，去归纳书中所有关于指针的知识点，来把这种东西理解透！
我之前在大学学习的时候，到了指针我就 很迷惑，这啥跟啥，怎么一会这样一会那样呢？？有没有定数！ 对，这个“定”字，是我非常疑惑的一点。为什么C++可以这样写也可以那么写？你跟我说一个死答案，告诉我就必须这么做我都不会像现在这么疑惑。后来越看越迷惑。我甚至打算总结一个C++写法归纳了!这玩意真是，对我这种记性不好纯靠理解的人来说，，非常不友好。
究其原因，我觉的是这种语言的多做之过！我知道这种多做对所有人来讲至少大部分人来讲，不算是多做！但是对于我这种死脑筋的，它就是多做！以至于我写代码的时候都会迟疑！

## 关于C++取值取地址，默认啥都不写取的究竟是个啥
- 如果你不加符号，存储的全部都是值！但是这个值长什么样子就得看这个变量在声明的时候是怎么声明的，如果你声明的是一个基础变量的话，那么这里面存储的内容就是这个值，但是如果你最开始声明的是一个地址的话，那么这里面的值，就是一个地址的数据，这个地址指向一块内存！
## 关于 &  与 * 关系的重新理解
- 星号，意指，直接得出指针所指向的地址的那块内存里面的内容。 你可以理解为跳区取映射，指向一块很遥远的地址。地址的位置就是你指针里面记录的位置。所以这个星号，它只能作用于一个指针而已， 我刚才自己试了，我给的如果是基础类型的话，直接加上星号的话，直接编译报错了就。所以这块可以确定，这个星号对指针有效。
- 但是 & 符号，就不一样了，它是可以作用于所有类型，从基础类型到复合类型，到指针，都可以用上这个的！& 符号的意思是，返回当前被操作数的地址。如果你的操作数是个指针的话，那么很明白，你加上&号， 那就是返回这个指针位置的地址。跟地址的地址有那么点相似。但是我现在思路有一些混乱，不知道是不是绝对的关系哈！

## 关于C++数组的数组名为什么是个point
在多数情况下， C++ 将数组名解释为第一个元素的地址！注意这里有一个细节就是，它是数组的第一个元素的地址，也就是头那个地址！。也就是说数组名它就是一个指针！这块就是这么搞的，那么如果一个数组是一个指针数组呢？？很明显，这个数组名它也是个指针，但是它是指针的指针呀！
## 关于C++ 数组怎么拿索引值转换的知识点复习
C++中是允许对指针进行算数运算的，但是指针的算数运算，如果你加了1 相当于原来地址的基础上再加上指针绑定的对象类型所占用的字节数! 所以有时候你想要在原地址上就加个1的话，这点其实也不是这么好办哈哈哈哈。C++对地址相加做了特殊的处理。

# 数组的替代品
vector 和 array 是数组的替代品！

## 我所使用的数组的症结
- 一个数组在声明的时候你总是得以各种各样的方式来指明这个数组的大小。但事实上，我们在开发的时候，有特别多的情况根本不知道到底需要多少个元素！所以这种情况下用数组真的很尴尬。我们不得不承认数组在查询上的效率是比较高的。但是有些情况用它并不是很合适。
- 有没有发现，new一个数组和delete一个数组有些麻烦!而且我们可能总是忘记写这种代码。如果有封装就好很多。
**Array是存在栈里的！！**刚看到这块我自己都惊到了，存在栈里？？什么鬼？

### 模板类 vector
```C++
# include <vector>
using namespace std;
...
vector<int> vi;
int n;
cin >> n;
vector<double> vd(n); //vector 竟然也需要指定容量？我实在不想指定容量操作啊。
...
```

### 模板类 array
array的长度也是固定的！啊啊啊啊，我不想学了！
五一假期还没有缓过来，效率不是很好啊！所以我打算硬着头皮先抄再说。
Vector类的功能比数组强大，但是付出的代价就是效率比较低，（为什么效率比较低啊？）， 如果您需要的是长度固定的数组，使用数组是更好的选择， 但是代价是不那么方便和安全。有鉴于此，C++11新增加的新的模板类array，也位于命名空间的std中，与数组一样，array的长度也是固定的，<font color=red>也是用栈(静态内存分配)， 而不是自由存储区</font>因此效率与数组是相同的。 PS： 讲真，存在静态存储区比存在自由存储区快？？我怎么觉得这里面没有绝对的因果关系呢？
Array与传统的数组来对比的话，Array更安全，更方便。尽管我不知道方便在哪里。 下面我们举个例子：
```c++
# include <array>
using namespace std;
array<int, 5> ai;
array<double, 4> ad = {1.2, 2.1, 3.43, 4.3};
```
这个语法跟上面的vector是有一些不同哈，但是也是以某种方式指定了这个数组的大小！
其实我一直不是很理解的是，为什么C++的语法这么不统一，这样会增加人的学习成本的！

### 比较数组，vector对象个array对象
