# 指针和自由存储空间

终于要学指针了-_-||， 我这块啊就是理解不到位。希望这次能学的透彻点。
我们学习一个变量的时候，一般是，先声明，再初始化。在这的底层其实涉及到计算机系统存储数据的时候必须跟踪的三种特点
- 信息存储在何处
- 存储的内容是什么
- 存储的信息是什么类型

只有这样才可以唯一的确定这段信息的位置，并且拿出来可以正确的进行使用。而我们的声明初始化啥的，就是告诉计算机这些特点，让他们开辟空间。
接下来我们学习另外一种比较重要的策略，这个策略也是之后我们非常非常经常用到的策略，那就是指针！
指针是什么呢？？指针是一个变脸！其存储的内容是**值的地址，而不是值本身！**在讨论地址之前，我们先看看如何获得一个变量的地址
## 如何获取一个变量的地址
& （地址运算符），只要对变量应用地址运算符，就可以获取它的位置。如下面的例子

```C++
# include <iostream>
using namespace std;
int main() {
    int dounuts = 6;
    double cups = 5.6;
    cout << " dounuts value is : " << dounuts << endl;
    cout << "duunuts addr is : " << &dounuts << endl;

    cout << " cups value is : " << cups << endl;
    cout << " cups addr id : " << &cups << endl;
    return 0;
}
```
![Snipaste_2022-03-22_12-16-23](/assets/Snipaste_2022-03-22_12-16-23.png)

我们可看到打一会的地址貌似是一个16进制的号， 并且，这俩变量的地址貌似是挨着的。对于为什么是16进制的数字呢，原因是我们的内存常用的就是16进制表示法。当然有些在实现的过程中采用的是10进制，因实现而定。但是你有没有发现，我在我的MAC上打印的地址，那个cups的地址竟然是比addr这个地址低的，这说明我这台设备的内存表示法，是低表示法。也就是内存地址号是递减的那种。

## 指针策略是C++内存管理编程理念的核心

星号“*”的衍生。这正是让我看不明白好多年的东西。我觉得我快得道了哈哈哈哈哈
在使用常规变量的时候，值是指定的量，而地址是派生量。

在使用<font color=blue>常规变量</font>的时候，值是指定的量，而地址是派生的量。地址是次要的。
处理存储数据的新策略刚好相反，将地址作为指定的量，而将值视为派生量。一种特殊类型的变量--指针，用于存储特殊值的地址。因此指针名表示的是地址。 * 运算符被成为是间接值或者解除引用运算符， 将其运用于指针可以得到指针存储的值。
eg： 假设manly指的是一个指针，manly在另外一个方面表示的其实就是一个地址。而*manly表示的是存储在该地址的值！ <font color=red>*manly与常规变量等效？？,这是啥意思？</font>

```C++
# include <iostream>
int main() {
    using namespace std;
    int updates = 6;
    int * p_updates; //地址的初始化，就是一个星，不用解释为什么这里会出现个星，死记硬背就成了
    p_updates = &updates;
    cout << " upsates = " << updates << " p_updates=" << p_updates << " *p_updates=" << * p_updates << endl; 
    *p_updates = *p_updates + 1;
    cout << "把地址内容取出，加了1之后看看：updates=" << updates << " *p_updates= " << *p_updates << endl;

    p_updates += 1;
    cout << "直接把地址值加了1之后看看：updates=" << updates << " *p_updates= " << *p_updates << endl;
    // *p_updates 指的就是，p_updates这个地址里面的那段内存，所存储的值！相当于反找！给地址看值。
    return 0;
}
```
![Snipaste_2022-03-22_15-42-26](/assets/Snipaste_2022-03-22_15-42-26.png)

由此可见
<font color = red> 
- 地址的声明方式是   地址内容类型 * 自己起的字符名称
- 地址的使用方式是， 直接用  自己起的字符名称 得到的是地址号， *自己起的字符名称 改地址里面的内存存储的内容。
- 将地址加1之后，指向的内存也就变了!所以你再调用 *p_updates 也不是原来那个值了，这是一块你不知道的内存。
- 你有没有发现，值的 & 运算 和 地址的 * 运算，正好是一对，作用也是互补的。
</font>

## 声明和初始化指针

