# 指针和自由存储空间

终于要学指针了-_-||， 我这块啊就是理解不到位。希望这次能学的透彻点。
我们学习一个变量的时候，一般是，先声明，再初始化。在这的底层其实涉及到计算机系统存储数据的时候必须跟踪的三种特点
- 信息存储在何处
- 存储的内容是什么
- 存储的信息是什么类型

只有这样才可以唯一的确定这段信息的位置，并且拿出来可以正确的进行使用。而我们的声明初始化啥的，就是告诉计算机这些特点，让他们开辟空间。
接下来我们学习另外一种比较重要的策略，这个策略也是之后我们非常非常经常用到的策略，那就是指针！
指针是什么呢？？指针是一个变脸！其存储的内容是**值的地址，而不是值本身！**在讨论地址之前，我们先看看如何获得一个变量的地址
## 如何获取一个变量的地址
& （地址运算符），只要对变量应用地址运算符，就可以获取它的位置。如下面的例子

```C++
# include <iostream>
using namespace std;
int main() {
    int dounuts = 6;
    double cups = 5.6;
    cout << " dounuts value is : " << dounuts << endl;
    cout << "duunuts addr is : " << &dounuts << endl;

    cout << " cups value is : " << cups << endl;
    cout << " cups addr id : " << &cups << endl;
    return 0;
}
```
![Snipaste_2022-03-22_12-16-23](/assets/Snipaste_2022-03-22_12-16-23.png)

我们可看到打一会的地址貌似是一个16进制的号， 并且，这俩变量的地址貌似是挨着的。对于为什么是16进制的数字呢，原因是我们的内存常用的就是16进制表示法。当然有些在实现的过程中采用的是10进制，因实现而定。但是你有没有发现，我在我的MAC上打印的地址，那个cups的地址竟然是比addr这个地址低的，这说明我这台设备的内存表示法，是低表示法。也就是内存地址号是递减的那种。

## 指针策略是C++内存管理编程理念的核心

星号“*”的衍生。这正是让我看不明白好多年的东西。我觉得我快得道了哈哈哈哈哈
在使用常规变量的时候，值是指定的量，而地址是派生量。

在使用<font color=blue>常规变量</font>的时候，值是指定的量，而地址是派生的量。地址是次要的。
处理存储数据的新策略刚好相反，将地址作为指定的量，而将值视为派生量。一种特殊类型的变量--指针，用于存储特殊值的地址。因此指针名表示的是地址。 * 运算符被成为是间接值或者解除引用运算符， 将其运用于指针可以得到指针存储的值。
eg： 假设manly指的是一个指针，manly在另外一个方面表示的其实就是一个地址。而*manly表示的是存储在该地址的值！ <font color=red>*manly与常规变量等效？？,这是啥意思？</font>

```C++
# include <iostream>
int main() {
    using namespace std;
    int updates = 6;
    int * p_updates; //地址的初始化，就是一个星，不用解释为什么这里会出现个星，死记硬背就成了
    p_updates = &updates;
    cout << " upsates = " << updates << " p_updates=" << p_updates << " *p_updates=" << * p_updates << endl; 
    *p_updates = *p_updates + 1;
    cout << "把地址内容取出，加了1之后看看：updates=" << updates << " *p_updates= " << *p_updates << endl;

    p_updates += 1;
    cout << "直接把地址值加了1之后看看：updates=" << updates << " *p_updates= " << *p_updates << endl;
    // *p_updates 指的就是，p_updates这个地址里面的那段内存，所存储的值！相当于反找！给地址看值。
    return 0;
}
```
![Snipaste_2022-03-22_15-42-26](/assets/Snipaste_2022-03-22_15-42-26.png)

由此可见
<font color = red> 
- 地址的声明方式是   地址内容类型 * 自己起的字符名称
- 地址的使用方式是， 直接用  自己起的字符名称 得到的是地址号， *自己起的字符名称 改地址里面的内存存储的内容。
- 将地址加1之后，指向的内存也就变了!所以你再调用 *p_updates 也不是原来那个值了，这是一块你不知道的内存。
- 你有没有发现，值的 & 运算 和 地址的 * 运算，正好是一对，作用也是互补的。
</font>

## 声明和初始化指针

我们在声明和初始化指针的时候都发生了啥呢？仔细想想哈，指针，里面存的就是一个地址，而且基本所有的地址值都是一样的位数，但是为什么在声明的时候让我们加一个```int* p_int;```这类的东西呢？？如果你以前看过别人写的代码的话，你是不是发现同一行代码，有的人是这样写：```int* p_int;```而又有些人是这样写的：```int * int```,甚至有些人连空格都直接去了。 其实对于这个细节，还真有考究。
首先指针存的的确就是一个地址而已，但是我们通常在使用的过程中，才没人关注它的地址是什么呢，我们横竖总归就是要捞到里面的值再进行加工计算的。想想，如果你的指针信息只有一个地址，它又有什么卵用呢？？即使定位到了内存，面对着后面一大坨的101010之类的数据，他自己都不知道怎么翻译呀！这个是大问题。也正是我们在声明的时候，非得指定这个指针的类型的原因！给了指针类型，指针到时候取值的时候，知道内存该读取到哪个位置，知道应该翻译成什么样的数据。这样才能满足正常使用的需求。
我们再看看```int* p_int;``这句话，是不是很容易理解为什么声明写成这个样子了
- int*   这是一个int类型的指针
- p_int 这个指针的名字叫做p_int

指针是一个复合类型，它就是由原始类型加上星号来进行声明的。想想你没有原始类型的话，的确是不知道怎么“翻译”的呢。所以它也是必须依赖一些其他基本类型才能有意义的一种类型，就像我们前面学过的，结构和共用体。都是复合类型

```C++
#include <iostream>
int main() {
    using namespace std;

    int higgens = 5;
    int* p_higgdns = &higgens;
    cout << "higgens=" << higgens << " higgens's addr=" << &higgens << endl;
    // &p_higgdns 这个是地址的地址， 这个有点饶了。我不想写这么绕的代码坑自己！
    cout << "p_higgdns=" << p_higgdns << " p_higgens's addr=" << &p_higgdns << " p_higgens's content=" << *p_higgdns << endl;
    return 0;
}
```

## 指针的坑
作者语重心长的总结了一些使用指针的常见问题，这块还是有必要专门记录一下的，以后自己可别这么坑，或者解决别人的问题的时候能够联想到这里以迅速解决问题就够了。

具体是什么意思呢？？你看看我们上面的例子，是不是有一行代码是这样的：

```C++
int higgens = 5;
int* p_higgdns = &higgens;
```
你永远不会晓得人有时候会多么粗心，作者说如果你写成这样子，就会出问题了
```C++
int higgens = 5;
int* p_higgdns;
*p_higgdns = higgens;
```
如果不仔细想想，这个代码看起来是不是没啥问题！实际上问题可不小，能写出这样代码的人，基础得薄成什么样子呀。
上面问题的关键是，p_higgdns里指向的内容，你给指定成了5，但是这个p_higgdns在内存的哪个位置啊？？你根本就没有告诉它。万一，这个位置是你关键程序的内存位置，，，你的程序各种崩溃你信不信。。因为你把某块内存位置的值给改了呀！！！！人家记录的万一是一个操作，上去操作系统就检测到你这个程序执行有问题了！

**所以作者给了一个大大的提示：指针使用之前一定一定要初始化！！！告诉它，自己的内容到底是什么地址！一定要让指针有一个确定的适当的地址，这是关于使用指针的金科玉律！！**

## 指针和数字
我们上面的例子中其实也观察到了吧，就是指针打印出来这个值的话，直接就是一个地址，这个地址看起来像是int型的，那么这样的话，如果我自己强制给指针赋值一个int型行不行呢？像这样：
```C++
int* p_custorm = 0xf5000;  ??
```
这样行不行，我让这个指针指向的是 0xf5000 的内存？？？有没有感觉一丝危险，做病毒的看到这里应该会很开心！
事实上C99标准发布之前是允许这样写的，但是C++的时候，给做了限制，，因为假设指针就是int型的，int除了加减之外还能计算乘除呢，但是你指针不能这么个计算法呀，所以指针在C++中，是一种类似于被包含的关系把，或者说指针是 int的缩窄版本。。想想，你把一个缩窄的变量赋值给一个更大域的类型，肯定不行啊。。所以在C++这里，它遵循原有的限制，就是，你可以这么搞，但是你必须进行**强制类型转换**才可以这么搞！正如：
```
int* p_custorm = (int*) 0xf5000;
```
这样才OK！但是我依然觉得，指针的这种操作真的很危险啊！！！因为如果你赋值的地址值正好是一个可以插入自己代码的值，那么人家直接可以将新的编译好的代码拷贝到内存中运行，完全OK的！！！这不就是一种类似于病毒的操作么！！！我觉得真心容易钻空子啊这种写法！

## 使用new来分配内存

指针真正的用武之地在于，在运行阶段分配未命名的内存以存储值，这种情况下，只能通过指针来访问内存。其实单单看这句话我是有些不是很理解的其实。
在前面的应用当中，我们都会将指针初始化为某个变量的地址，变量的本质其实是一段有名字的内存，而指针只是给这种变量(通过名称就可以直接访问其内容，的这种内存名称)提供了一个别名。我们用  *别名，也是可以访问这里的内容的！事实上，你能保证所有的内存都给起一个名字么？这个在现实中其实是不太容易做到的!
在C语言中，我们通过malloc来分配内存，在C++中，仍然可以这样做，但是很麻烦。C++直接提供了一个关键字来做这件事，也就是new关键字！
new 关键字都干了啥？
在看书之前我们不妨推测一下： 
```
int* p_int = new int; //里面的细节
```
p_int 是一个指向int类型的指针是吧，但是初始化之后，它里面的内容指的是哪个地址呢？我不理解！
书中的解释是： new int 告诉程序，需要适合存储int的内存，new运算符根据类型来确定需要多少个字节，然后它找到一个符合的内存区域，并返回了地址。说白了，就是C++帮你做了一个指针的初始化工作，并且初始化的值指向的是一块你不知道，但是相对安全的一段内存区域！！！这块内存区域其实连个名字也没有，不像我们在上节讲的，名字叫higgens啥的，它根本就是没有名字的一段内存！C++的术语，把这个说成是“数据对象”！至于这个数据对象，可能是一个结构，也可能是一个基本类型！
语法：
```C++
typeName* p_name = new TypeName; 
```

**在我的理解，指针就是指向一段内存，而new就是开辟一段内存，我有点不明白，这两个概念明明没有关系，为什么作者非要写在一起！**

例子：

```c++
#include<iostream>
int main() {
    using namespace std;
    int nights = 1001;
    int* pt = new int;
    *pt = 1001;

    cout << "nights value is:" << nights << " nights addr is: " << &nights << endl;
    cout << "pt content value is:" << *pt << " pt is: " << pt << endl;

    double* pd = new double;
    *pd = 1000001.1;

    cout << "size of pt: " << sizeof(pt) << endl;
    cout << "size of *pt: " << sizeof(*pt) << endl;
    cout << "size of pd: " << sizeof(pd) << endl;
    cout << "size of *pd: " << sizeof(*pd) << endl;

    return 0;
}
```

通过new出来的内存，会被存在堆内存或者自由存储区内

### 空指针
值为0的指针为空指针，所以你会看见别人代码里面为啥有一堆判断是否为0的东西。其实是在判断空指针

### delete 释放内存

```c++
int* p_int = new int;
....
delete p_int;
```
delete的意思是释放 指针所指向的内存。但并不意味着指针自此没了这个指针可以再被赋值应用！ delete在使用的时候一定记得和new关键字配对使用！否则会引发严重的内存泄漏问题。
对了，如果你释放一个已经被释放过了的内存区域，照样也会出错。。我觉得限制这么多，这家伙能好使么！另外，你同时也不能delete来释放声明变量所获得的的内存。
条条框框的，我都敬而远之了要，这也不行那也不行，这样出错那样出错，提供一个这么难用的东西干嘛。

- 不要使用delete来释放不是new分配的内存
- 不要使用delete来释放同一个内存块两次
- 如果使用new[] 为数组分配内存，则应该使用 delete[]来释放
- 如果使用new 为一个实体分配内存，则应该使用delete来释放
- 对空指针应用delete是安全的！

我们上面提到了数组和方括号，是这样的，数组也是可以new出来的，但是new的时候语法有点不一样
```C++
int* pt = new int[100];
```
这样的话在delete的时候，务必也加上方括号，以释放的是全部的数组，而不仅仅是指针的位置。
```C++
delete [] pt;
```

**我有一个疑惑就是，delete之后处理的指针，既然还能被再赋值，那么当再赋值之前，它自己是什么呢？它指向的地址的内容又是什么呢？我们不妨自己写一个例子试一下**
我自己写了个例子发现有些奇怪!

```c++
#include<iostream>
int main() {
    int a = 15;
    int* p_int = &a;

    using namespace std;
    cout << "a's addr=" << &a << endl;
    cout << "---------------not new -----------------------" << endl;
    cout << "p_int = " << p_int << "And p_int's content=" << *p_int << endl;

    int* p_bint = new int;
    *p_bint = a;
    cout << "---------------new -----------------------"<< endl;
    cout << "p_bint=" << p_bint << " and p_bint's content=" << *p_bint << endl;
    cout << "---------------delete p_bint----------------------"<< endl;
    delete p_bint;
    // 尽管我已经释放了但是打印出来的结果依然跟没有释放前似的，一切都是正常的，我感觉有点奇怪这里！！！所以内部到底发生了什么呀，难道是加了一个标志位？
    cout << "after delete p_bint, p_bint=" << p_bint << endl;
    cout << "after delete p_bint, *p_bint=" << *p_bint << endl;

    cout << "---------------new int array-----------------------"<< endl;
    int* p_cArray = new int[3];
    *p_cArray = 1;
    *(p_cArray + 1) = 2;![Snipaste_2022-03-25_11-23-35](/assets/Snipaste_2022-03-25_11-23-35.png)
    *(p_cArray + 2) = 3;

    cout << "p_cArray=" << p_cArray << " p_cArray's content=" << *p_cArray << endl;
    return 0;
}
```

![Snipaste_2022-03-25_11-24-14](/assets/Snipaste_2022-03-25_11-24-14.png)