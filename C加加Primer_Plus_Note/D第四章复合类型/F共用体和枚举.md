# 共用体
共用体一听这个名字，就会感觉共用这个词，肯定有其解释的意义。共用体是一种比较特殊的数据结构， 他们能够存储不同的数据类型，但是统一时刻下智能存储这些"不同的数据类型”中的其中一种数据类型。其用途是，当一个数据项使用两种或者多种类型进行表示（但是同一时刻下只能用一种类型进行表示），采用共用体可以在一定程度上节省空间！
例如管理一些小商品的目录，但是他们的ID有时候是整数，有时候是一个字串。这种情况下，我们用共用体就行。

共用体可以用在结构中，但是不知道是不是能独立使用哈。
例子：
```C++
# include <iostream>
int main() {

    struct widget{
        char brand[20];
        int type;
        union id{    //关键词是 union
            long id_num;  //这两个同时只能用一个哈！
            char id_char[20];
        } id_val;
    };
    widget prize;

    return 0;
}
```

## 匿名共用体
匿名共用体顾名思义就是把名字去掉，那么此时我们可能就会想了，没有名字我需要怎么调用呢？就像下面的代码：
```C++
struct wigget{
    char brand[20];
    int type;
    union{
        long id_num;
        char id_char[20];
    };
};  //就像这样从头到尾都没有一个名字
```

用的时候这样去用！

```C++
widget mW;
mW.id_num = 1;  //就这样直接点出来就行了！
```

## 关于共用体一些底层的知识
上面我们已经强调过了，匿名共用体里面声明的变量是不能同时使用的，而且其目的就是可以用来节省空间。（但是事实上真的节省了么，我觉得并没有办法做到极致的节省）。 但是他们怎么就节省了空间的呢？为什么其声明的变量无法做到同时使用呢？原因可以回归成一个其实：
**正如上面例子中的id_num和id_char, 他俩在底层实则共用的是同一个地址！！！同一个地址请注意啊，所以你写代码的时候只需要注意，这俩“身份”到底那个是活跃的就行了。。既然是同一个地址，但是既然让我们这样写，肯定也有一套规则来保证我们书写的安全的，这个共用体的大小，就是以占内存大的那个为自己的大小。其实好好想想就能反应过来，因为只有这样的话才最安全！**

共用体经常用于节省内存，但并非只应用于节省内存。目前我们的设备存储的容量都已经很大了，对于这样的设备，是没有什么必要去节省内存。但是除了电脑之外，其实有很多其他的电器啥的也是用C++来写的，例如嵌入式编程的这堆。烤箱啊，MP3播放器啊，或者漫步者的处理其啥的。对于这样的程序而言，内存是十分宝贵的资源。此外，共用体还经常被用于操作系统的数据结构和硬件数据结构。

# 枚举
C++中枚举的使用跟java中是比较像的
```C++
enum spectrum{red, orange, yellow, green, blue, violet, indigo, ultraviolet};
```
这句话有两个过程
- 让 spectrum 成为一个新类型的名称，注意，是新类型的名称，我觉得这一句讲的是比较精辟的！ spectrum 被称为枚举，就像struct的变量被成为结构一样。
- 将 red，yellow等等这几个作为符号常量，他们对应的数值分别为0 到 7， 即使这么个规则，从0开始。这些常量我们称之为枚举量
  
那么我们怎么用他们呢？

```C++
spectrum band； //java中也是这么用的其实
// 之后用的时候就这样
band = red;
band = yellow;
// 但是你不能
band = 2000; //因为值受限，最大就是8而已
```
枚举只可以有赋值操作，不能进行赋值。一般人也不会这么用吧。
枚举可以转换成int型，但是int是不可以转换成枚举的！
具体原因我不细看了，但是作为一个开发者你最好老老实实使用枚举，就像java那样使用枚举就行，最好别进行乱七八糟的运算操作！有坑。你看你在Java上这样用枚举不？对吧。
但是这里有一个细节不知道你注没注意到， 就是，我们之前在java中学习，枚举的话，其实我们也可以有值的。 但是java中声明值有点乱！有点麻烦。 C++在这里实际上的书写方式是比java方便的。例如
```C++
enum spectrum{red, orange = 200, yellow = 250, green = 300, blue, violet, indigo, ultraviolet};
```
但是有个细节是，red的值是0，就像我们数组从0一样的规则，但是yellow被我们指成200了，后面的是green， 直到blue。其实此时的blue已经是301了，枚举默认后面比前面一个大1，如果没有特别指定，那么后面的就是加1 ，所以blue是 301.

## 枚举可以直接用值来进行赋值
我们看看语法

```C++
enum bits{one = 1, two = 2, three = 3};
bits myFlag;
myFlag = bits(3);  这里也就是 three了。
```
我觉得这样定义也挺方便的，但是有时候肯能会带来危险，因为对于枚举而言，它是有阈值的，你声明的是0 到 3，但是你传入了一个越界的值在里面，肯定会出现问题的！想想，如果你不确定这个赋值里面是不是3或者它就是一个不确定的值的话，尤其是服务端传来的值直接做转换的话，一定要小心了！这很可能会出现向后兼容崩溃的问题。这种问题也不小！
