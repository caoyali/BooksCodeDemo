# 类型转换
和java基本是一样的， 就是， 小转大没有问题，但是大转小会出现问题。会出现精度相关的问题。

# 类型转换发生的时机
- 将一种算数类型的值赋给另外一个算数类型的变量的时候， c++对值进行转换
- 表达式包含不同类型的时候，C++将对值进行转换
- 将参数传递给函数的时候，C++将对值进行转换

如果不知道进行这些自动转换时将要发生的情况，将无法理解一些程序的结果。所以了解这些东西是有些必要的哈。

## 初始化和赋值的时候进行的转换
C++是允许将一个类型的值赋值给另外一个类型的变量的，期间会发生类型转换， 转换的结果以接收的变量类型为准。也就是， a  是 long， b 是 short 的话。 a = b; 是被允许的，并且short会被转换为long， 这种情况下精度是安全的， 但是反过来就有些危险了， 比如把 long赋值为一个short类型， 我们已经知道short能表示的数字是相当有限的，而long可以表示的类型就多得多。这种情况下强制转换的话实际上是存在很多风险的。就像我们在java里学到的那样。

### bool值的赋值
对于bool值， 默认 0 就是false， 非0 就是true。 这个需要记一下， 我之前老是记反。

```c++
#include<iostreame>
using namespace std;
int main()
{
    cout.self(ios_base::fixed, ios_base::floatfield);
    float three = 3; // 这个值转换完之后精度更大了
    int guess(3.9832); // 竟然有这种初始化方式啊啊啊啊！！！！！   guess是一个int类型的，3.nn是float， 会砍掉精度
    int debt = 7.2E12;   //为什么执行的是4098这个我就不明白了， 不应该是 72000这样格式的么， 这个书上说就是这样， 不同的编译器显示的值也可能不同的！
    cout << "three = " << three << endl;
    cout << "guess = " << guess << endl;
    cout << "debt = " << debt << endl;
    return 0;
}
```


![Snipaste_2022-02-10_21-54-58](/assets/Snipaste_2022-02-10_21-54-58.png)

### 一种更加安全的初始化赋值写法--采用大括号
```c++
const int code = 66;
int x = 66;
char c1 = {31325}; // 这行在实际情况下是会报错的， 原因是这个写法对赋值涉及的类型转换检测更为严格。我们好好看这些代码，很明显会失去精度，是不安全的。
char c2 = {66}; //  这行是可以编过的，因为66在char所能表示的范围之内。
char c3 = {code}; // 同上，是可以通过的！
char c4 = {x}; //这行代码是有问题的， 原因很简单， 66 不是常量，随时会变的，那么这样的话，x很可能会大于char所能表示的值。这样的话就又出现了失精度的问题。
const int y = 1099999;
char c5 = {y}; // 这行是会报警的， 原因是这个y值太大了，看来c++对值的内容也是有校验的。我觉得这个挺好的
```
![Snipaste_2022-02-11_13-29-41](/assets/Snipaste_2022-02-11_13-29-41.png)

## 表达式中涉及到的转换

### 整数系列在表达式中的转换
之前我们说过， 对于C++而言，最符合其计算的类型其实是整型，因为这个， 有时候，c++在计算一些可以转换为整型的数的时候，会偷偷的先把他们转换为int然后再进行计算之后，最后再进行一次转换。 下面我们看看这个例子， 这个例子是书中给出的例子，由于这种转换我们完全没有办法去证实， 但是作者既然这么说，至少说明c++历史中的的确确存在这么个情况。

```c++
short a = 10;
short b = 20;
short c = a + b; // 这个就是表达式哈！很惭愧我连表达式是个啥都不知道。 就是在这个细节，会发生上述我提到的事情。
```

情况就是这么个情况， 那么具体的转换规则是什么呢？ 碰见什么会发生转换呢？无脑转肯定会出问题的。
我先在忙别的事情了，之后更新。
### 浮点系列和整数系列混合在表达式中的转换