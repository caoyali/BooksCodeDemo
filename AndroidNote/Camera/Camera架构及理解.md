# Android Camera架构
链接：
官方文档： https://source.android.google.cn/docs/core/camera
中断： https://blog.csdn.net/sshcx/article/details/1445569?spm=1001.2101.3001.6650.17&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-17-1445569-blog-111667407.pc_relevant_multi_platform_whitelistv6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-17-1445569-blog-111667407.pc_relevant_multi_platform_whitelistv6&utm_relevant_index=19

## 历史
个人最喜欢从历史开始研究，尤其是Android这种经历了 camera1 camera2的发展状况，更加好奇！


## 前情提要
### 管道
因为各大文章中都提到了camera底层管道这个事情，所以我们之前还是回顾一下管道这种东西吧。说实话。我快把这里忘干净了。感觉跟新学似的。管道是用来解决跨进程通讯的一种方案哈。我在这里，就多一层科普吧。其余的我也没有精力去看了。

### 以操作系统角度分析跨进程通信
**跨进程通信万变不离其宗的是，找出一块公共的内存区域，进行修改或者读取。** 但是基于这套实现，我们不可避免的要解决以下几种问题
- 竞争条件，这个看起来挺高大上的，其实核心就是类似于多线程操作共同的数据，引发数据不安全的那种情况。只不过这里是进程


要搞定竞争条件， 操作系统要做的核心是，确保互斥。而操作系统毕竟作为一个系统级的设计，必须要在完成目的的情况下尽量的减少对效率的损耗。对于一个比较好的解决方案，首先需要满足以下原则
- 任何两个进程是不可以同时处于其临界区的
- 不应该对CPU的速度和数量做任何假设。也就是完全删去这种概念，需满足所有情况
- 临界区外运行的进程不可以阻塞其他的进程。也就是，临界区外，A自己阻塞就阻塞，但是不能A的阻塞，就顺便也把其他的CDE阻塞了。这样是很有问题的。
- 不得使进程无限等待进入临界区。

#### 解决竞争条件问题

##### 屏蔽中断
**屏蔽中断** 是操作系统的一个词，我们先了解一下这是个啥哈。
据我的理解，
**中断** 就是CPU在执行当前程序的时候，由于系统出现了某正需要处理的紧急情况，CPU暂停正在执行的程序，转而去执行另一段特殊程序来处理出现的紧急事务，处理结束后CPU自动返回到原先暂停的程序中继续执行，这种执行过程由于外界的原因被中间打断的情况称为中断。
我们可以通过中断让处理器转而去优先运行正常控制流之外的代码。当中断信号到大的时候CPU必须停止他正在做的事情，并且切换到另外一个活动，为了做到这个，就要在内核态堆栈保存程序计数器的当前值，并把与中断类型相关的地址放在程序计数器中。
那么通常什么情况下我们会产生中断呢？比如，当在键盘按下的时候会得到一个中断信号，这样的话，CPU就不会死守着等待键盘输入，如果硬盘度写完之后发送一个中断信号，CPU就可以腾出手来集中精力服务大众了，无论是人类敲打计算机的之间还是回读写介质的磁头，跟CPU的处理速度相比，都太慢了。没有中断机制，单靠CPU轮询是绝对耽误生产力的。
**中断分类**
- 可屏蔽中断： I/O设备发出的所有中断请求（IRQ）都可以产生屏蔽中断
- 不可屏蔽中断： 只有几个危急事件(如硬件故障)才会引起非屏蔽中断。非屏蔽中断总是由CPU辨认。
- 处理器异常：当CPU执行指令时探测到一个反常条件所产生的异常（故障，陷阱，异常终止）
- 编译异常：在编程者发出请求时发生，是由int或者int3指令触发。

那么屏蔽中断的意思在这里也不难理解了。就是A干着活，无论来了什么中断，不care，继续做当前的任务。

那么计算机是如何靠硬件和软件配合来协同处理中断过程的呢？CPU执行完一条指令之后，下一条指令的逻辑地址会被存放在CS和EIP这对寄存器中，在执行新指令前，控制单元会检查在执行前一条指令的时候是否有中断或者异常发生。也就是，执行完会插入检查这个环节。如果有异常或者中断发生，控制程序就会抛下来指令，进入以下流程：
- 1 确定中断或者异常的关联向量。
- 2 寻找向量对应的处理程序
- 3 保存当前的工作现场， 执行中断或者异常处理程序
- 4 处理程序执行完毕之后，把控制权交换给控制单元
- 5 控制单元恢复现场，<font color=red>继续执行原来的程序</font>

关于中断的详细处理请看链接：  https://blog.csdn.net/sshcx/article/details/1445569?spm=1001.2101.3001.6650.17&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-17-1445569-blog-111667407.pc_relevant_multi_platform_whitelistv6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-17-1445569-blog-111667407.pc_relevant_multi_platform_whitelistv6&utm_relevant_index=19

好， 那么我们再回过头来看这个**屏蔽中断**， 为什么屏蔽中断就能解决竞争条件的问题？原因是，CPU只有在接收到时钟中断或者其他中断的时候才会进行进程切换， 屏蔽中断的同时顺便也把时钟中断也给屏蔽了，这样的话，CPU没有这些中断自然就不会切换到其他的进程。所以它在这种情况下修改共享内存时，不用担心其他程序的介入了。这样想想是好的，但是又有一个问题了，**<font color=red>当代计算机是多核的!这套理论在多核的情况下，很鸡肋!原因是，一个核屏蔽了中断，没办法阻止其他核屏蔽中断啊！</font>**屏蔽中断对于操作系统是一件很实用的技术， 但是对于用户线程而言，不是！