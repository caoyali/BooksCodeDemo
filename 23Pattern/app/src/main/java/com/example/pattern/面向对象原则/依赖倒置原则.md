# 依赖倒置原则
我写这个自然段的时候，还没有具体的看依赖倒置的含义。也就是不知者，不知者就算理解错了也无罪哈哈。
我现在有三个疑问， 何为依赖， 何为倒置(因为我感觉这个名字起得，有点让人不太好理解！)， 依赖为何倒置？
目前在我看来，依赖关系，是一个对象作为另一个类的某个方法的参数， 那么他俩是依赖关系。 那么倒置是什么含义？与我之前理解的是否有偏差？

study...begin
## 何为依赖倒置
#### 依赖
这里的依赖并不是我之前想的，代码中的依赖关系。而是XXX做成什么事情需要用到ZZZ这种行为的抽象，在这个里面，XXX是高层，ZZZ是低层。 例如CPU要展示文字需要用到显示器， CPU为高层， 显示器为低层。
#### 何为倒置
我们从反面思考，这句话的意思是，倒置是对的，而"正置"是错的！那么理解为，正常情况下，我们不做约束，可能出现的情况正是"正置"这种情况。 而这种情况在编码里面，在设计中是不对的。例如我们设计一款CPU， 最开始的时候有AB两个厂家用到了， 如果我们不进行设计的话， AB厂家对他们的硬件进行修改，为了是适应他们的修改，我们的CPU也得进行修改！ 这简直就是荒唐， 这种就是正置的情况， 即 **上层随着下层的改变而改变**， 就像皮肤的状态随着身体状况的改变而改变。 这种说法并没有说它多么不对，这种谁随着谁改变，本身上是中性的，没有对与错。 但是如果用到架构的设计中，这种情形下遵循这种显然会有问题的！
而倒置的理解，正好反过来了！**下层依据上层的改变而改变， 或者是，上层绝对不根据下层的改变而改变，这种事情不能做！**， 就像现实生活中的CPU， 所有接口都是定好的，甚至几年内不会发生改变。所有下层的相关显示器厂商，不管是什么型号，多么高级或者多么普通，屏幕多大多小，最终都必须遵循CPU已经订好的接口！CPU的设计是非常复杂的，如果随着底层的改变而改变的话，那难度简直就是修罗模式不可能的！实际上也就是这样的。

**所以简单总结就是：依赖倒置的白话解释就是，上层需要依赖下层才能完成一个更为全面的功能，但是上层不可根据下层的改变而改变，反之的话是十分不好维护的！所以就是，上层定义抽象接口，下层没有迫使其修改的权利，无论内部逻辑实现再复杂，也要遵循给定的接口。我认为这种规范对于编码的模块化设计具有十分重要的意义。当然，我认为这样也会要求编写的人员具备很好的业务能力以及抽象能力。**
**另外，这里提到了 “遵循给定的接口”这里在代码中的体现，也应当是接口欧！这样比较解耦！** 如果想看案例和演变过程，请在百度上随便搜这个词条！

#### 依赖倒置的意义
- 降低耦合，你懂的
- 增加代码的可维护性和可读性
- 增强代码的稳定性(可维护性高，稳定性自然不会差)
- 降低并行开发引起的风险(同上，可维护性高，代码易读，就算不同人修改，或者扩展，稍微看看就能明白，开发风险自然小， 我总结，这条和上条，是废话。)
