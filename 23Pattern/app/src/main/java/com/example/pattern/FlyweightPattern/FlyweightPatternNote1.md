# Flyweight
## ?
**1 享元模式倡导共用一个，那么如果涉及多线程对数据操作，是否会出问题**
答： 享元，共享的那部分，几乎是不可改变的那部分。即使是多线程如何搞，也是用的不可更改的，大家共享的那一部分。既然是不可更改。那么对于线程安全问题，自然是减小了许多这种风险。而对于不可共享的那一类。如果你例子看的足够多，你会发现，这部分的数据在使用的时候，通常直接生成一个新对象，并且用在一个特定的“具有组装bean这种意义的”方法中，以方法参数的形式被传进去。那么最初我质疑的那种可能会在堆中存在很多对象这种疑虑就被打消了。因为他们被存储到了方法栈中被临时使用，出栈即销毁。
通过亲身经历再一次证明，遇到很懵的问题之后，不要死磕，放着它先不管，忙忙其他的事情。我这次这个问题让我放了一个月。一个月后再衔接，不仅衔接的很快，并且对于之前的疑惑会有一种豁然开朗的感觉。会多出很多与之前不一样的理解。有的人吧真的不是很适合大块时间只做一件事。我就是这种典型。做事情我是不会放弃的，但是会出现想看什么就看什么从而导致某个事情会搁置一段时间的情况。好在搁置再久也会衔接起来。这样至少不会使自己做事有太大的压力，压力大了容易生病。但需要注意的是，不要兴趣太广泛，导致最后自己分不清重点。来来回回就搞这两三样就行。
**2 提供是否是可用状态？有没有具体的使用场景，或者代码？**
？ 单例工厂？但是感觉仍然无法解决多线程对的共享对象的修改问题啊
？ 把可变的定为不可变的？
1 还是不是很透彻
2 感觉Android不太用啊，这种模式。而且我想不出来什么情况下非得这么搞
我现在有些理解了享元模式的含义，但是仍有地方疑惑，就是我认为享元模式是在很特殊的情况下才适合使用。
- 1 非共享元素的 参数， 如果是从别的对象上提取出来的，那么很可能意味着这个对象是在某处创建的， 如果这个对象的创建不是复用的，而是new出来的，就很可能意味着，生内存的目的没有实现彻底。然后从反面想，非共享元素的参数不是从对象中取出来的，而是从屏幕获取的？或者从某个单一的对象里面获取的，那么就意味着，这种很可能是出发了某种操作，临时取得值，而且这种值取值成本特别低。想想这种情况下的适用场景其实并不是特别多的。反导是典型的文件编辑器，用户编辑文字的时候，会马上利用享元模式拿出缓存对象，附上目前用户已经设置好的颜色属性(从单一处取值)， 字体(从单一处取值)， 然后将这个对象设置完全之后立即交给算法部分，以这个对象为参数立即计算出屏幕缓冲需要的数据。我认为也就是类似这种场景需要享元模式而已。 也就是，拿到享元对象之后，会立即用它做指定的计算，传到方法参数里面去，方法执行完就接着执行下一个，周而复始？这样的场景比较合适。其余的还真是想不到啊！
- 2 如果共享元素的单元里面存在对象的引用， 多线程情况下，一旦被某线程将这个引用拿出来做操作，那就很可能引发问题。面对这种情形 ，是如何避免的。 还是享元单元的规定，变量必须是基础类型，这样会比较靠谱？


### 引入
享元模式经典的例子，是文档编辑器的实现。将每一个文字展示在屏幕上，涉及到每一个字符的相关数据存储， 字符展示的位置是一种数据。字符的图像信息是一种数据据。文档上假如有几千万的文字，很显然，我们是不可能存储几千万个相关的数据的！在这里我们首先想到的看看某些数据对象存储空间，能不能共享。
我认为享元模式的核心不止是搞懂"享元"这个含义是如何实现的。还有，享元中的什么内部状态和外部状态。这个是关键。至于什么简单享元，复合享元。我认为前面的搞懂了，其余的是费不了多少脑力就可以了解的。
- 内部状态
- 外部状态
- 共享（存住，如果有就拿出来用，没有就创建一个并存住）

### 核心代码
```java
享元对象.操作方法(非享元部分作为参数)
```
我之前觉的怪，不理解。可能是我觉得，享元对象就是一个bean，凭什么让他做“操作”？这不是一个bean该干的事情啊。所以我第一次看享元对象的时候有这么多的不适应。因为我自己写代码的时候，绝对会规避这种的。不过，我感觉这只是一种表现形式而已。如果看不惯，大不了用骚操作硬是吧这块分离呗。又没人拦着你。