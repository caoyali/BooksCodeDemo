# 操作系统结构
在上一章的时候我们提到过，对于设计操作系统而言，系统目标的明确定义非常非常重要！在此重述来强调一下这个的重要性。因为有了这些目标，我们在实现的时候才能采取合理的策略和算法。这个决定了你的操作系统该如何设计。
操作系统三个维度的基本要求：
- 对用户而言，要注重系统提供的服务
- 对程序员而言，要关注用户和程序员采用的接口
- 对操作系统设计人员而言，需要明确系统组件及其相互关系。

## 2.1操作系统服务
很多的其实，直接上图。大部分功能其实很好理解的
<a href="https://sm.ms/image/Z8AuRqGTtBdmiw6" target="_blank"><img src="https://i.loli.net/2021/08/25/Z8AuRqGTtBdmiw6.png" ></a>

```puml
@startmindmap
* 操作系统的结构;
 * 用户角度，操作系统服务;
  * 1操作系统界面;
   * 命令解释程序;
    * win dos;
    * Linux shell;
    * Unix shell;
   * 批处理程序
   * GUI
  * 2程序的执行;
  * 3I/O操作;
  * 4文件系统操作;
  * 5通信;
  * 6错误检测;
  * 7资源分配;
  * 8记账;
  * 9保护与安全
 * 客户程序员角度，操作系统api提供;
  * 系统调用;
   * 调用传参方式;
    * 寄存器传参;
    * 存在内存的块表中;
    * 将参数压入到堆栈，并通过操作系统弹出;
   * 调用类型;
    * 进程控制
     * 进程的创建，终止
     * 进程的加载，执行
     * 进程的结束，中止
     * 获取和设置进程属性
     * 等待时间
     * 等待事件，信号。
    * 文件管理
     * 文件的创建，删除
     * 文件的打开，关闭
     * 文件的读，写，重新定位
     * 文件的属性 获取，设置
    * 设备管理
     * 请求设备，释放设备
     * 读，写，重新定位。 这个和文件管理有些相似了哈。
     * 获取设备属性，设置设备属性。这个与文件的管理同样类似。
     * 逻辑附加或者分离设备
    * 信息维护，这个我不想码了。
    * 通信
     * 创建删除通信连接
     * 发送，接收消息
     * 传送状态信息
     * 附加或分离远程设备

 * 操作系统开发者本身，系统组件及其相互关系
  * 文件管理
  * 状态管理
  * 文件修改
  * 程序语言支持
  * 程序加载与执行
  * 通信
  * 后台服务
@endmindmap
```
## 用户与操作系统的界面
首先明确下，操作系统的界面相关，不属于操作系统内核的内容。这个家伙只不过是衍生出来的相关服务而已。

```puml
@startmindmap
* 用户与操作系统界面
**:命令解释程序
就是我们通常所说的命令行;
*** 不同系统中解释程序的名字
**** unix--shell
**** linix--关键词shell
**** windows--DOS
***:解释程序开启时机，首先他很特殊
在一个任务开始或者用户登陆的时候就开始运行;
***:shell的主要功能实现方法
主要功能是获取并执行用户指定的下一条命令;
**** 自己”解释“命令自己执行
**** 直接将指定文件加载到内存并执行！无视文件中的含义。
**:GUI
这个是我们最熟悉的，就是桌面程序更亲民
不做多余解释;
@endmindmap

```
命令行与GUI比较
命令行更适合高手操作，并且由于其具有可编程功能，所以更适合执行一些想重复性的步骤
GUI嘛就是上手很快。更加面向普通用户。

## 2.3 系统调用
程序员写的一个很简单的程序，就会引发出非常多的系统调用。比如拷贝文件这一个操作哦，就会涉及到很多的系统调用，牵扯到很多的服务部分。例如找不到文件的界面返回，弹窗，复制粘贴涉及到的鼠标，GUI等等一系列的。并不是程序员调用API这么简单。里面涉及到的门道特别多。
而且系统调用实际上有多频繁呢？--一秒钟成千上万次！

操作系统由哪些语言实现的呢？ C， C++, 需要直接访问级硬件的则会用汇编来实现。

向操作系统传递参数有三种常用方法
- 寄存器传参
- 有时候参数的数量比寄存器要多，参数会存在内存的块中或者表中，块或者表的地址通过寄存器来传递。
- 压入到堆栈中，并通过操作系统弹出。有的系统比较偏爱这种方式。