# 操作系统结构
在上一章的时候我们提到过，对于设计操作系统而言，系统目标的明确定义非常非常重要！在此重述来强调一下这个的重要性。因为有了这些目标，我们在实现的时候才能采取合理的策略和算法。这个决定了你的操作系统该如何设计。
操作系统三个维度的基本要求：
- 对用户而言，要注重系统提供的服务
- 对程序员而言，要关注用户和程序员采用的接口
- 对操作系统设计人员而言，需要明确系统组件及其相互关系。

## 2.1操作系统服务
很多的其实，直接上图。大部分功能其实很好理解的
<a href="https://sm.ms/image/Z8AuRqGTtBdmiw6" target="_blank"><img src="https://i.loli.net/2021/08/25/Z8AuRqGTtBdmiw6.png" ></a>

```puml
@startmindmap
* 操作系统的结构;
 * 用户角度，操作系统服务;
  * 1操作系统界面;
   * 命令解释程序;
    * win dos;
    * Linux shell;
    * Unix shell;
   * 批处理程序
   * GUI
  * 2程序的执行;
  * 3I/O操作;
  * 4文件系统操作;
  * 5通信;
  * 6错误检测;
  * 7资源分配;
  * 8记账;
  * 9保护与安全
 * 客户程序员角度，操作系统api提供;
  * 系统调用;
   * 调用传参方式;
    * 寄存器传参;
    * 存在内存的块表中;
    * 将参数压入到堆栈，并通过操作系统弹出;
   * 调用类型;
    * 进程控制
     * 进程的创建，终止
     * 进程的加载，执行
     * 进程的结束，中止
     * 获取和设置进程属性
     * 等待时间
     * 等待事件，信号。
    * 文件管理
     * 文件的创建，删除
     * 文件的打开，关闭
     * 文件的读，写，重新定位
     * 文件的属性 获取，设置
    * 设备管理
     * 请求设备，释放设备
     * 读，写，重新定位。 这个和文件管理有些相似了哈。
     * 获取设备属性，设置设备属性。这个与文件的管理同样类似。
     * 逻辑附加或者分离设备
    * 信息维护，这个我不想码了。
    * 通信
     * 创建删除通信连接
     * 发送，接收消息
     * 传送状态信息
     * 附加或分离远程设备
     * 两大模型
      * 共享内存模型
      * 消息传递模型，<font color=red>对于这个模型，有没有专门的硬件支持呢？</font>

 * 再往上一层的系统程序-操作系统开发者本身，系统组件及其相互关系
  * 文件管理
  * 状态管理
  * 文件修改
  * 程序语言支持
  * 程序加载与执行
  * 通信
  * 后台服务
@endmindmap
```
## 用户与操作系统的界面
首先明确下，操作系统的界面相关，不属于操作系统内核的内容。这个家伙只不过是衍生出来的相关服务而已。

```puml
@startmindmap
* 用户与操作系统界面
**:命令解释程序
就是我们通常所说的命令行;
*** 不同系统中解释程序的名字
**** unix--shell
**** linix--关键词shell
**** windows--DOS
***:解释程序开启时机，首先他很特殊
在一个任务开始或者用户登陆的时候就开始运行;
***:shell的主要功能实现方法
主要功能是获取并执行用户指定的下一条命令;
**** 自己”解释“命令自己执行
**** 直接将指定文件加载到内存并执行！无视文件中的含义。
**:GUI
这个是我们最熟悉的，就是桌面程序更亲民
不做多余解释;
@endmindmap

```
命令行与GUI比较
命令行更适合高手操作，并且由于其具有可编程功能，所以更适合执行一些想重复性的步骤
GUI嘛就是上手很快。更加面向普通用户。

## 操作系统的结构
### 简单结构
简单结构是操作系统最开始的结构，最初的dos就是简单结构，简单到哪种地步呢？就是任何模块的程序都能访问硬件这种程度。
![image.png](https://i.loli.net/2021/09/13/XU8jiFs7nuNY2EG.png)

ROM BIOS设备驱动-> MS_DOS设备驱动-> 常驻系统程序-> 应用程序，
<font color=#FFA54F>从图中可以看出弊端，就是任何模块都能访问底层，是很不安全的，但是为什么这么写呢？原因是这个时期的内存少得可怜，发展初期呢。</font>

### 分层结构
操作系统分为若干层，最底层为硬件层，最高层为用户接口，要求每层只能调用更底层的接口和服务，不能反着来。用以简化调试和验证的过程。

### 微内核

微内核是伴随着系统不断变大而来的。微内核是一种技术，其各个模块之间的通信靠的是消息传递。这样做的好处是一个模块除了问题，其他模块不会为此受到影响。

### 模块

这里的模块指的是可加载的内核模块。内核提供的是核心服务，但是其他服务可以在内核运行时动态实现。
