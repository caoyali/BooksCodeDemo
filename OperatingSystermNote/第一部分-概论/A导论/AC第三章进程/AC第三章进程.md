# 进程的概念
早期同时只能执行一个程序-> 执行多个程序， 势必会出现很多问题要求我们做更好的划分。进程出现。
进程是现代分时系统的工作单元
进程只有在程序执行的时候才算是执行，还没加载到内存的哪些可执行文件可不算什么进程哈！
一个程序可以包含多个进程，这个还用说么？但是他们之前这种关系，势必发生数据交互，这是另外一章专门解决的问题。    
进程的统筹，编纂出来的代码需要哪些软硬件准备？
- 程序计数器硬件，用以表示下个指令和一组相关资源
- 处理器，寄存器硬件
- 进程堆栈（软件）
- 数据段（软件）
- 堆(软件)

综上所述：进程是现代分时系统的单元，必须在执行的时候才算。用以软件造出进程的概念需要很多硬件的搭配。

# 进程的状态
进程的状态，与线程神似
- 新的
- 就绪
- 运行
- 等待
- 终止
![Snipaste_2021-10-11_13-53-10](/assets/Snipaste_2021-10-11_13-53-10.png)

# PCB 进程控制块
为了整合上述的所有边角料资源，我们需要将这些物件抽象出来。也就是进程控制块

- 宏观操作系统进程调度相关
  - 进程的状态记录
  - CPU调度信息：主管进程优先级，调度队列等
- 现场恢复类
  - 程序计数器， 主要记录下一个指令的地址， 便于回复的时候知道从哪里执行
  - CPU寄存器， 保存当下瞬间的所有现场涉及到的硬件的值。 便于恢复的时候数据不会算错，正常执行。硬件信息主要包括以下：
    - 累加器
    - 索引寄存器
    - 堆栈寄存器
    - 通用寄存器
    - 条件码信息寄存器
- 其他
  - 内存信息管理
  - 记账信息
  - IO装备管理
# Linux系统软件层面上的进程表现形式
Linux是用C语言编写的，我们前面讲了形成一个进程是需要这样或者那样的环境或者边角料的，但是无论是怎么样回归到软件上肯定会有一个软件上的东西用于整合这些资源， 调度这些东西，使其形成进程的概念的。 其实计算机软件总归不过就是这几个事情嘛。 Linux系统也不例外，也得有硬件整合的抽象表现形式， 就是<linux/sched.h>这个库接口。
Linux上的整合，进程是一个双向链表， 有父进程，子进程， 兄弟进程的概念。这些其实了解就可以了。

# 线程
首先你要了解的一个历史是， 线程的出现是晚于进程的！是我们的硬件不断升级之后，出现的必然结果。说起概念，是一个进程包括n个线程。但是早期，一个进程就是一个线程。真不是渐渐的这种方式已经不适合复杂的场景了，就又搞出的线程这么个东西。
一个进程里面有n个线程，本质上的处理方式是一样的，线程也是PCB这一套机制可以兼容实现的。但是这个一对多的关系， 使得进程控制块这个家伙后期又在维护的东西里面加上了一些能记录线程的信息。不管怎么实现，反正能找到。
就是这么搞的。看来不是每个人做事都是完美的。历史总是不完美的，没办法一步到位哈哈哈。

# 进程调度实现的大致原理
总归是，数据结构加算法。靠数据结构来实现的。
进程调度的最终目的是，通过合理的调度，使得CPU时时刻刻都有工作在做。并且最好还能更加高级，使得每个进程都可以执行，提高用户体验。
那么如果我们是开发者我们怎么思考呢？
## 数据结构
- 进程有不同的生命周期， 其实就是一个flag值，我得把一些特殊flag值得东西进行分类，收集起来。所以
  - 我要分类
  - 我要有数据维护进程， 其实存的就是进程控制块。 是不是有些豁然开朗了。数据结构其实就是进程控制块的数据维护
- 我还有很多其他的硬件设备呢？比如IO，我还有这类的应用场景呢！比如等待输入一个字符！
  - 所以我要每一个设备都有对应的设备列表， 列表中每一个节点存储的，还是那个进程控制块！
- 我们至少确定了，要根据不同的场景维度，写不同的队列。队列要用链表实现， 链表的每一个节点代表了一个PCB。 所以这个节点哈， 不只有本PCB内容， 还有有一个 pre 和 next节点引用。这个是非常传统的链表实现方式没什么可说的。

对，进程的调用，就是利用这堆数据，维护各个节点生命周期值， 其实就是进程的生命周期，抉择运行哪个程序的， 或者程序要求用设备的时候，我们会把进程转到另外的设备队列中，等等都有可以实现的数据依据了。
计算机系统看似复杂，其实单拎出来每一个知识点其实还是能够让人理解的。
## 算法
调度队列有不止一个哈！很多的，分类也很清楚。 程序会因其生命周期的不同而在这多个队列中跳来跳去的。这个是专门的调度程序来写的。
进程置放于大容量存储设备的缓冲池中--》长期调度程序从这里拿程序--》 装入内存以备于后期的执行
短期调度程序从内存中选择进程，并直接给他们分配CPU。

综上所述，CPU就是那个任劳任怨的工具人啊。

有的分时操作系统，不一定非要有长期调度程序的。五花八门。还有的分时系统，用了中期调度程序。专注于将进程从内存换入和换出。 交换官方给的词是 swap。其实我们大概猜到了为什么加这个东西，可能是小内存设备需要，比如手机。书上还加了个作用是改善内存组合。

# 上下文切换
上下文切换是一个任务。 首先你要理解两个部分，1 上下文是什么， 2 切换是什么。
- 上下文，指的就是之前你学的，PCM，即进程控制块
- 切换， 将CPU切换到另一个进程，需要保存当前进程的状态，并恢复另外一个进程的状态。这种过程就叫做上下文切换。这种过程是需要时间开销的。并且这个开销是因硬件的不同而有所差异的。

# 进程操作
着重进程的创建和删除

## 创建
进程是一个树形结构，有父进程，子进程之分。下面是solaris操作系统的进程结构和作用，很明显的树形结构。
  ![Snipaste_2021-10-18_13-55-40](/assets/Snipaste_2021-10-18_13-55-40.png)

进程创建出来的进程是子进程。
- 从执行顺序上讲有以下两种：
  - 父进程与子进程同步执行，等到子进程执行完父进程再继续执行
  - 父进程不管子进程，两者异步执行。
- 从内存创建上也有两种方式
  - 从父进程上拷贝一份内存，内容一模一样
  - 从父进程的内存区里面划出一块作为子进程的内存区域

不过最有趣的是fork函数，这个家伙竟然会返回两次，颠覆了我之前的认知啊！这个东西为什么是返回两次，得好好研究一下啊！
<font color=red>fork的时候，其实做的是子进程完全拷贝主进程，拷贝一个，所以当时的PCB里面的东西应该也是一样的，当CPU执行任务的时候，可能莫名其妙的多出了一个，但是这个人家也不关注，PCB内容也是一样的，就意味着，代码执行到哪里了，目前的结果是什么，应该有与之前的父进程是一模一样的。CPU切的时候也是拿着PCB里面的内容恢复的啊。所以表面上看起来返回了两次，打印了两次，实际上你要是能打印出来进程号的话，就能看出来区别了。至于为什么两者返回值不一样，我觉得这个我不感兴趣，因为我想怎么返回就怎么返回。有的是办法。</font>
所以才有了以下的诡异代码！
![Snipaste_2021-10-19_13-58-50](/assets/Snipaste_2021-10-19_13-58-50.png)

## 删除&终止
进程终止的根本目的是用于释放资源的。
调用的方法是exit()函数。这个我感觉自己写脚本的时候也是这样写，不知道是不是这种也是本书中涉及到的进程。
终止原因大概有以下几个：
- 父进程退了，有些操作系统是级联终止的，所以它手底下所有的子进程也得终止
- 父进程被要求有个检查子进程状态的机制， 当子进程使用了超过它所被分配到的资源的时候，就会被终止。我们平常所看到的的内存溢出啊，包括空指针啊，归根结底都是内存的位置错了。
- 分配给子进程的任务已经不再需要。其实我觉得有时候子进程也会终结掉自己啊！
  
# 进程间通信
进程间为什么要通信呢？因为我们的进程就它能做成的事情，性质区分而言，包括两种：
1 一个进程做光了所有的事情，这种称之为独立进程。这个是很简单的
2 但是更为常用和高级的是，多个进程共同完成一个比较大的事情。这个就涉及到了协作的问题，进程间通信机制就是为了这种多进程通信而产生的！那么这种协作方式为我们带来的好处是：
- 计算加速
- 模块化，安全，一处模块有问题，不会牵连整个程序全部挂掉！
- 为了用户使用体验上的方便

业界有两种方案来解决进程间协作这个事情
- 1 共享内存方案
- 2 消息传递方案

共享内存方案相对于消息传递而言，处理是比较快的，因为毕竟是内核开了内存之后基本就没有过多的维护了，而消息传递，每次都得走一次内核的。
但是科学证明随着处理器多核的产生，共享内存实际上因为其他的技术原因，优势越来越小了，原因是多级缓存数据同步这块。越多越复杂，把优势拖没了快。

## 共享内存方案
由操作系统内核的代码去开辟一段公共的存储空间，之后把这个空间地址交出去，给别的进程用，从此操作系统就不会做多余的维护了。
其实这个也是有一定道理的，因为内存空间开不开的出来，只有操作系统才能知道的！所以这个活只能由它去做。
那么这个内存一般会从哪里开始开辟呢？
答：一般会在生成共享内存的进程的地址空间中开一个内存段。

其实道理都懂，书里面还给了一个生产者消费者模式来着，通常会用到一些线程来解决，但是我这里的疑惑是，为什么线程wait就不执行，notify之后就执行了，他们的硬件基础是什么呢？答案是线程调度器这个家伙。
<font color=red>其实我还有一个问题，就是我不明白为什么书里讲共享内存的时候又提到了生产者消费者模式。我并没有从文中看到相应的关系啊。这个疑惑之后再看看，说不定之后的文章有详解，就会全通了。</font>

## 消息传递方案
你可以将消息传递直接抽象为不同设备与不同设备之间的数据传递。因为这都属于同一种性质的通用解决方案，即使是事实上发生在同一个设备内进行消息传递。但是只要你的思路出发点足够抽象，通常能解决整一类这样的问题，而设备内的通信只是一种比较特殊的场景，就像正方形之于长方形。公式是通用的，只不过正方形比较特殊而已。

其实本质上来讲，消息传递方案其实是操作系统比较负责的为我们做了更多的事情
共享内存的思路是，我操作系统给你们扔出一段空间来，之后我就啥也不管了，你们爱拿这段空间干啥就干啥。而生产者消费者模式只不过是比较适合针对共同的操作空间数据变化通知这种使用场景，从而被程序员广泛的使用起来。其实事实上，操作系统很不负责的扔出了一段空间而已，其余的基本没干啥。操作系统就是一个牵线搭桥的角色，就像给你建一个群之后就啥也不管了，就做了这么点事情。
但是消息传递这种方案。操作系统就做的更多了。他自己就是一个路由中心了，收发都知道，转给谁也必须控制。他不得不建立一套适用于所有场景的通用机制。自己搞一套通信链路。而对于通信本身而言，又有以下几种分类

### 直接通信， 进程无中介，直接进行通信
- 对称性
  A说，把我的消息xxx发给B进程
  B说，我要接收A进程的消息
  这样的实现机制是，A与B之间建立一条唯一的专用通道链路！这种链路，只与两个进程相关，不能再多了。
  一切都是指名道姓，精准到一对一！
- 非对称性通信
  A进程说，给B进程发送xxx消息
  而B进程说，我要接收所有进程的消息，没有指名道姓到底收到谁的。
  这种关系明显不是1v1的了。

而这样有个不好的点是，一处发生更改，就要处处改，更改的时候很是麻烦。

### 间接通信
将发送的目标抽象成，邮箱或者端口。可以有不同的邮箱，每一个邮箱都有一个唯一的值。相当于各方发送者中间多了一个管理枢纽，如果几方使用者都将消息发到了这个枢纽中的话，那么这个枢纽经过更高级的算法进行中转分发。当然这个枢纽是操作系统本身来实现的。
对于这个邮箱的所有者，可以是操作系统，当然，自己的邮箱也可以搞一个邮箱出来。不过如果是自己的进程弄的话，这个内存地址也是相应进程中开辟的一段内存。当然如果你这样做的话，可得注意一下邮箱的生命周期问题。开邮箱的进程死了，邮箱也就不复存在了。

但是刚才讲到了。操作系统自己也有个系统级别的邮箱的。我感觉作者这样写，很可能操作系统自己做了一套邮箱机制，报错增删查改的操作，然后操作系统通过自己这个机制开辟了属于自己的邮箱，当然这个邮箱的生命周期应该很长，很可能只要电脑有电，它就活着。同时操作系统八成还把这套机制封装成了API以供第三方开发者使用，这样的话，操作系统估计就可以完成所有消息的全面掌控。 想象一下，如果电脑运行着断电了，但是操作系统可能已经做好了所有消息的管理，早就备份了。那么我们电脑重启的时候，就会从原来的操作中恢复过来，该是一件多么炫酷的事情啊

其实这种消息发送的核心机制也是逃不了生产者消费者模型的。因为毕竟最终的机制无非是在内存的某一个地方开一个空间，写入或者读取。而我们之前已经讲到了生产者消费者模型很适合多个线程共同操作同一段内存的。其实我们用了类似的机制，和阻塞队列差不多。接受者收不到消息的时候就阻塞，直到有消息来。，发送者没有消息可以发送的时候就阻塞，直到有了新的消息。

文章中还提到了关于队列容量的问题，包括，零容量，有限容量，无限容量。这些都不是重点，看见字我大概都明白了什么意思。

##案例

## 对于算法方面
搞算法的主要目的就是完成程序调度。着重就是调度的处理来来着。
### POSIX共享内存
```puml
@start
```