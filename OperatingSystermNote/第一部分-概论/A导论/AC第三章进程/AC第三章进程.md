# 进程的概念
早期同时只能执行一个程序-> 执行多个程序， 势必会出现很多问题要求我们做更好的划分。进程出现。
进程是现代分时系统的工作单元
进程只有在程序执行的时候才算是执行，还没加载到内存的哪些可执行文件可不算什么进程哈！
一个程序可以包含多个进程，这个还用说么？但是他们之前这种关系，势必发生数据交互，这是另外一章专门解决的问题。    
进程的统筹，编纂出来的代码需要哪些软硬件准备？
- 程序计数器硬件，用以表示下个指令和一组相关资源
- 处理器，寄存器硬件
- 进程堆栈（软件）
- 数据段（软件）
- 堆(软件)

综上所述：进程是现代分时系统的单元，必须在执行的时候才算。用以软件造出进程的概念需要很多硬件的搭配。

# 进程的状态
进程的状态，与线程神似
- 新的
- 就绪
- 运行
- 等待
- 终止
![Snipaste_2021-10-11_13-53-10](/assets/Snipaste_2021-10-11_13-53-10.png)

# PCB 进程控制块
为了整合上述的所有边角料资源，我们需要将这些物件抽象出来。也就是进程控制块

- 宏观操作系统进程调度相关
  - 进程的状态记录
  - CPU调度信息：主管进程优先级，调度队列等
- 现场恢复类
  - 程序计数器， 主要记录下一个指令的地址， 便于回复的时候知道从哪里执行
  - CPU寄存器， 保存当下瞬间的所有现场涉及到的硬件的值。 便于恢复的时候数据不会算错，正常执行。硬件信息主要包括以下：
    - 累加器
    - 索引寄存器
    - 堆栈寄存器
    - 通用寄存器
    - 条件码信息寄存器
- 其他
  - 内存信息管理
  - 记账信息
  - IO装备管理
# Linux系统软件层面上的进程表现形式
Linux是用C语言编写的，我们前面讲了形成一个进程是需要这样或者那样的环境或者边角料的，但是无论是怎么样回归到软件上肯定会有一个软件上的东西用于整合这些资源， 调度这些东西，使其形成进程的概念的。 其实计算机软件总归不过就是这几个事情嘛。 Linux系统也不例外，也得有硬件整合的抽象表现形式， 就是<linux/sched.h>这个库接口。
Linux上的整合，进程是一个双向链表， 有父进程，子进程， 兄弟进程的概念。这些其实了解就可以了。

# 线程
首先你要了解的一个历史是， 线程的出现是晚于进程的！是我们的硬件不断升级之后，出现的必然结果。说起概念，是一个进程包括n个线程。但是早期，一个进程就是一个线程。真不是渐渐的这种方式已经不适合复杂的场景了，就又搞出的线程这么个东西。
一个进程里面有n个线程，本质上的处理方式是一样的，线程也是PCB这一套机制可以兼容实现的。但是这个一对多的关系， 使得进程控制块这个家伙后期又在维护的东西里面加上了一些能记录线程的信息。不管怎么实现，反正能找到。
就是这么搞的。看来不是每个人做事都是完美的。历史总是不完美的，没办法一步到位哈哈哈。

# 进程调度实现的大致原理
总归是，数据结构加算法。靠数据结构来实现的。
进程调度的最终目的是，通过合理的调度，使得CPU时时刻刻都有工作在做。并且最好还能更加高级，使得每个进程都可以执行，提高用户体验。
那么如果我们是开发者我们怎么思考呢？
## 数据结构
- 进程有不同的生命周期， 其实就是一个flag值，我得把一些特殊flag值得东西进行分类，收集起来。所以
  - 我要分类
  - 我要有数据维护进程， 其实存的就是进程控制块。 是不是有些豁然开朗了。数据结构其实就是进程控制块的数据维护
- 我还有很多其他的硬件设备呢？比如IO，我还有这类的应用场景呢！比如等待输入一个字符！
  - 所以我要每一个设备都有对应的设备列表， 列表中每一个节点存储的，还是那个进程控制块！
- 我们至少确定了，要根据不同的场景维度，写不同的队列。队列要用链表实现， 链表的每一个节点代表了一个PCB。 所以这个节点哈， 不只有本PCB内容， 还有有一个 pre 和 next节点引用。这个是非常传统的链表实现方式没什么可说的。

对，进程的调用，就是利用这堆数据，维护各个节点生命周期值， 其实就是进程的生命周期，抉择运行哪个程序的， 或者程序要求用设备的时候，我们会把进程转到另外的设备队列中，等等都有可以实现的数据依据了。
计算机系统看似复杂，其实单拎出来每一个知识点其实还是能够让人理解的。
## 算法
调度队列有不止一个哈！很多的，分类也很清楚。 程序会因其生命周期的不同而在这多个队列中跳来跳去的。这个是专门的调度程序来写的。
进程置放于大容量存储设备的缓冲池中--》长期调度程序从这里拿程序--》 装入内存以备于后期的执行
短期调度程序从内存中选择进程，并直接给他们分配CPU。

综上所述，CPU就是那个任劳任怨的工具人啊。

有的分时操作系统，不一定非要有长期调度程序的。五花八门。还有的分时系统，用了中期调度程序。专注于将进程从内存换入和换出。 交换官方给的词是 swap。其实我们大概猜到了为什么加这个东西，可能是小内存设备需要，比如手机。书上还加了个作用是改善内存组合。

# 上下文切换
上下文切换是一个任务。 首先你要理解两个部分，1 上下文是什么， 2 切换是什么。
- 上下文，指的就是之前你学的，PCM，即进程控制块
- 切换， 将CPU切换到另一个进程，需要保存当前进程的状态，并恢复另外一个进程的状态。这种过程就叫做上下文切换。这种过程是需要时间开销的。并且这个开销是因硬件的不同而有所差异的。

# 进程操作
着重进程的创建和删除

## 创建
进程是一个树形结构，有父进程，子进程之分。下面是solaris操作系统的进程结构和作用，很明显的树形结构。
  ![Snipaste_2021-10-18_13-55-40](/assets/Snipaste_2021-10-18_13-55-40.png)

进程创建出来的进程是子进程。
- 从执行顺序上讲有以下两种：
  - 父进程与子进程同步执行，等到子进程执行完父进程再继续执行
  - 父进程不管子进程，两者异步执行。
- 从内存创建上也有两种方式
  - 从父进程上拷贝一份内存，内容一模一样
  - 从父进程的内存区里面划出一块作为子进程的内存区域

不过最有趣的是fork函数，这个家伙竟然会返回两次，颠覆了我之前的认知啊！这个东西为什么是返回两次，得好好研究一下啊！
<font color=red>fork的时候，其实做的是子进程完全拷贝主进程，拷贝一个，所以当时的PCB里面的东西应该也是一样的，当CPU执行任务的时候，可能莫名其妙的多出了一个，但是这个人家也不关注，PCB内容也是一样的，就意味着，代码执行到哪里了，目前的结果是什么，应该有与之前的父进程是一模一样的。CPU切的时候也是拿着PCB里面的内容恢复的啊。所以表面上看起来返回了两次，打印了两次，实际上你要是能打印出来进程号的话，就能看出来区别了。至于为什么两者返回值不一样，我觉得这个我不感兴趣，因为我想怎么返回就怎么返回。有的是办法。</font>
所以才有了以下的诡异代码！
![Snipaste_2021-10-19_13-58-50](/assets/Snipaste_2021-10-19_13-58-50.png)

## 删除&终止
进程终止的根本目的是用于释放资源的。
调用的方法是exit()函数。这个我感觉自己写脚本的时候也是这样写，不知道是不是这种也是本书中涉及到的进程。
终止原因大概有以下几个：
- 父进程退了，有些操作系统是级联终止的，所以它手底下所有的子进程也得终止
- 父进程被要求有个检查子进程状态的机制， 当子进程使用了超过它所被分配到的资源的时候，就会被终止。我们平常所看到的的内存溢出啊，包括空指针啊，归根结底都是内存的位置错了。
- 分配给子进程的任务已经不再需要。其实我觉得有时候子进程也会终结掉自己啊！
  
# 进程间通信
