# 复杂度概念重温
- 时间复杂度
- 空间复杂度


## 时间复杂度

### 概念
简单来讲，就是一个算法执行完需要的时间。当然时间是越短越好。
然后我们扩展，什么才影响这个时间值呢？ 归根结底，是代码执行的总次数。次数越多，越花费事件，这点很好理解吧。
在我们看网站的时候，是不是经常看到 O(n^2)，  O(1) 这种鬼样子的东西来描述复杂度？这个都是大家经常看到的。我现在就把每一个部分拆开来解析一下这里面的概念。
拿 O(n^2) 来举例，怎么理解这个家伙。我们拆成 O, (), n, n^2 这几处看。

#### O
数量级的标识符。在这里你可以强制理解为： 唯一意义就是说明，其后面的公式，是用来描述复杂度的。

### ()
括号中就是公式，就是这么个写法。不做过多描述

### n
问题规模。这个是一个比较抽象的概念。 比如我对一个100个元素额数组做排序， 这个n可以指的是 100.  就是原始数据量级的一个代名词。

### n^2 
这个是描述一个复杂度的核心。就是计算代码执行次数。严格点来的话，你可以计算的一点都不差，但是我们通常不会这么计算的。只是给几个常见的典型的关系就行了。下面是常见的几个关系。一堆典型的数学函数，但是我忘得差不多了。之后捡几个高中数学符号给自己”科普“一把。哈哈哈

| 常数阶 | 对数 | 线性阶 | 线性对数阶 | 平方阶 | 立方阶 | 省略很多其他的阶 | K次方阶 |  指数阶 |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ----|
|O(1)| O(log2 n) | O (n) | O (n log2 n)| O (n²) | O (n³) | 省略其他很多阶 | O （n 的k次方）| O (2 的 n次方)|

从左到右复杂度越来越高。

### 根据几个复杂度复习下初高中数学

#### O(1) 
这个只是说明无论n多么大，算法的执行次数是一定的。例如计算1万条数据，执行次数为 100， 计算10万条数据，执行次数依旧为100.

#### O(log2 n) 
首先复习下对数的概念

如果 a的x次方=B, 那么 x 就是以a为底， B的对数。  也就是算  a 的 次方数的。
那么 log2 n 的意思是   以2为底， n的对数。 2 的 log2 n 次方 = n   

这么推算下来，这种复杂度的算法，当n越大的时候，效果理应约显著。 推也能推出来。 log 2 32 = 5； log 2 64 = 6； 当n发展的越来越大的时候，这个值的变化却并不是特别大。挺好的。

至于更深层的理解，我觉的在真真正正的学习算法的时候肯定会遇到。 听说二分法就是对数复杂度。可以体会一下。
#### O(n)     

这个也很好理解。n多大，就将近多少次。

#### O(n²) - O(n的k次方)
不做解释

#### O(2n )
指数，这种是最不好的了。

总结下来，看来我好像只对对数不甚了解了，指数的概念忘了，一看公式就想起来了。其余的还可以呀。

#### 其实还有个复杂度 n！这种一看就不是很稳定。 n越大，越差。设计算法要懂避坑。
我们可以计算一个公式，当n为4的时候，n！就已经会比n方 大很多。  n！这个好像与n的几次方关系没有可比性。 n越大，这家伙越危险。当然，会比n的n次方好上很多。
总之这种算法不是很好就对啦。

### 时间复杂度计算方式
本质上是执行代码的次数，但是会有以下几个点要注意。

- 忽略常量。比如
```
for (int i = 0; i < n; i ++>) {
    aaaaa;
    bbbbb;
}
```
此时会循环n次，每次循环便会执行两行代码。那么严格算起来就是 2 * n， 但是2 这个常量我们会不纳入计算之中。

- 默认计算的是最坏情况下的复杂度。 比如从小到大对一个数据进行排序，但是这个数据的内容恰好是 从大到小排的。 排序的时候不得不做一系列的内存拷贝动作。这种情况就是最不乐观的

- 关注运行的增长趋势，正如前面讲到的数学公式。那些公式随着n的不同会产生巨大的变化， 最后的那个指数，想象一下，如果n趋近于无穷大，将多么可怕。这个趋势很是重要的！非常重要！
- 递归算法的时间复杂度为：递归总次数 * 每次递归中基本操作所执行的次数

- 计算复杂度有一个比较简单的计算方式， 有几重for循环， 一层一次方，例如一层for循环为n， 两层为n方， 3层为n的三次方。不难理解吧。 并且注意二分！二分为对数级的复杂度， 如果是一个for循环套了一个二分， 那么就是线性对数。

## 空间复杂度

空间复杂度指的是，要此算法要得出结果，需要借助多少个辅助空间来完成。这个辅助空间（单元数）就是空间复杂度。

递归的空间复杂度为递归深度，越深越复杂度越高。
这个空间复杂度应该不能理解吧。 

