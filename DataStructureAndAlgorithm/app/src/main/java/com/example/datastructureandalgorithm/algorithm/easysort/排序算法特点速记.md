# trans
为防止面试的时候脑子突然空白，呵呵，这是我经常出现的问题，一面试，所有的思路知识仿佛被瞬间清空。可能是心理问题。首先我们记一下置换两个index数据内容的心决。
由于很多算法涉及到置换两个索引里面的数据内容。所以要特意记一下。免得到时候慌了。

```java
temp = a;
a = b;
b = temp;
```
记住出现次序是 ： temp， aabb temp。  aabb这个环节很重要，死记硬背也要对。

# 指针相关套路
由于链表什么的经常要更换指针什么的，这个基本也是套路，遇到了总结。但这个肯定会有。

# 冒泡排序速记
两两相比，边比边换，逐鹿卷王。n趟下来，自然排好序。

# 选择排序速记
找出最大的一个，记住索引位置，索引位置哈！等每一趟找出来之后，将这个最大位置的索引位置的数据，与当前趟最后的一个索引数据调换一下，这样就选完了。

# 插入排序速记
永远假定前面的数据是有序的！事实其实也是如此。
两层循环，一层代表要排几个数，并且这些已经有序了。第二层代表往前插入的新数，会捋着往前找，该置换的就置换，知道碰见不能置换的条件，马上终止所有循环！
左手的牌，永远都是排好序的。k的赋值为i，代表前方已经有i张排好的牌了。右手拿的牌就是 k + 1, 倒着(往前！往前！这个特别重要)遍历，交换，直到遇到不能交换的情况。我今天写完之后立马就忘了，等到希尔排序的时候，我竟然忘掉了插入排序的实现方法了。原因就是上述这一点，我没有记住。
不断往前交换，交换即插入，直到交换至合适的位置。所以位置到了，就停止交换了，下一遍遍历。

# 快排速记
可以想象一个画面，这个画面很诙谐且很形象。我把前后index想象成了两个大头兵。
[点击查看动画](https://upload-images.jianshu.io/upload_images/1940317-3bf6002ba2c0b90b?imageMogr2/auto-orient/strip)
- 左小右大中基准，二分递归三循环。循环是一个外套的，并内嵌两套。所以是两层。
- 内部循环体是从end开始往前推还是从start开始往后推，取决于基准值取得是谁。取start，就从end往前推。取end，就从start往前推。窍门是，让谁空，下一步就开始想办法填谁。基准值，一定要取start 或者 end index的某个值，否则会出错。原因是取出一个值就代表那个index的值暂时就废掉了，得补进去正确的值。
- 替换无需swap，往前中间推的时候，小心index推超。
- 明天最好再写一遍。

**再写一遍**
```java
public void quickSort(int[] data, int start, int end) {
    if (start >= end || start >= data.length || start < 0 || end >= data.length || end < 0 ) {
        return;
    }

    int oldStart = start;
    int oldEnd = end;

    int p = data[start];
    while(start < end) {
         while(start < end && data[end] > p) {
            end --;
        }

        data[start] = data[end];
        start ++;

        while(start < end && data[start] < p) {
            start ++;
        }

        data[end] = data[start];
        end --;
    }

    data[start] = p;
    quickSort(data, oldStart, start - 1);
    quickSort(data, start + 1, oldEnd);
}
```
# 希尔排序速记
- 增量，分组， 排序是插入排序！
- 循环是四层。
  - 1 层算增量
  - 1 层用来指定目前是哪一组，总共有增量个组
  - 其余两层，就是插入排序的那种套路。插入排序要两层，大家都晓得。
- 对于希尔排序比插入排序慢的事实。答案是跳跃太大会导致操作系统分页频率高，由此会消耗很多时间。但是理论上希尔排序比快排会好上很多。主要还是看运行它的机器。