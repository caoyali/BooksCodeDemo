# 1.02对RTTI的需要
[上一页：1.01类型信息简介](/ThinkingInJava原版/类型信息/1.01类型信息简介.md)
#### 重温多态性
多态性的主要覆盖两大功能是：
- 1 向上转型：
  这个是在前期绑定里面做的。运用场景是，某个方法的参数是一个基类，但是写代码的时候，是可以传一个声明时为子类的对象过去，明明类型不一样，但是编译依然不报错！主要实现原理是在前期绑定这个阶段，java能够知道某一个子类是某个父类的孩子。在编译期的时候，只要是属于这个基类即可。所以不报错。
- 2 向下转型
这个是在后期绑定中做的。
    - 主要使用场景是，
      - 1，你持有一个当时只知道类型信息为基类或者接口的实例，但是你知道这个对象更为精准的类型信息，也就是你知道这个对象基本是隶属于哪个子类，这个时候，可以运用小括号进行强制转型。然后调用以某些专属于子类的方法也是没问题的。
      - 2 第二种常用的场景，也就是面向对象的精髓， 就是以基类的类型调用某一个基类的方法，代码的逻辑实现就会执行到对应子类的重写方法。以此体现完成多态！
    - 实现原理是：对象里面自动会内置一些类型信息，在运行时会有一种专门的机制用来确保会调用到正确的方法体里面去！


##### 多态的目的
从程序设计的角度讲：就是尽量运用面向对象中各种对象的共性，尽量以基类的形式调用各种方法，然后执行的是子类的代码。以此来达成有代码改动的时候，需要改动的范围面达到最小。
多态的一个目标就是能够更好的面向对象编程。

```java
package com.example.typeinfo;

import java.util.Arrays;
import java.util.List;

/**
 * 电子书 394页
 * 由多态谈及动态类型
 */
abstract class Shape {
    void draw() {
        System.out.println(this + ".draw()");
    }

    public abstract String toString();
}

class Circle extends Shape {
    @Override
    public String toString() {
        return "Circle";
    }
}

class Square extends Shape {
    @Override
    public String toString() {
        return "Square";
    }
}

class Triangle extends Shape {
    @Override
    public String toString() {
        return "Triangle";
    }
}

public class Shapes {
    public static void main(String[] args) {
        // 当这句话执行的时候，事实上已经发生了向上转型！
        // 编译时，进行类型检测，以至于在写代码的时候，就强制我们把类型给成了既定的样子 shape，但是对于shapeList
        // 而言，它存储的依旧是Object类型。为什么给你的假象是它存储的是你写好的尖括号里面的<Shape>？原因是
        // 这段代码在取出元素的时候，利用RTTI机制，在运行的最后，把类型转成既定的样子!
        List<Shape> shapeList = Arrays.asList(new Circle(), new Square(), new Triangle());

        for (Shape shape : shapeList) {
            // 这段代码在取出元素的时候，利用RTTI机制，在运行的最后，把类型转成既定的样子!
            // 那么RTTI的大致机制是什么呢？在运行时检测所有的类型，以确保类型的正确性。在运行时，才给以确切的类型！
            shape.draw();
            System.out.println(shape);
        }
    }
}

```

#### RTTI是一种什么样的机制，用来做什么的？
上述例子已经在注释中做了描述，RTTI是保证在运行中，给与正确的类型。是检测也好，转换也好，总之就是在运行中，操作和类型信息相关的事情。
为了加深记忆，建议再看看上面的shapeList例子！

#### 小结
对RTTI的需要主要是为了完成面向对象这一特性，我们经常在程序运行时主动的需要或者被动的判断当前类的类型信息，包括父类信息，或者是接口信息，或者是当前精确的类型信息。
以完成一些共性中有差异，类别中有细分这类的代码设计。为了完成这种，全面的类型信息，就十几的重要。RTTI就是和类型信息相关的机制，发生在运行时，去完成的就是“和类型相关的事情”， 包括，转型，类信息，接口，甚至反射的支持。


[下一页：1.03Class对象](/ThinkingInJava原版/类型信息/1.03Class对象.md)