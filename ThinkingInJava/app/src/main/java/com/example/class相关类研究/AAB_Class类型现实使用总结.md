最近工作中， 由于需要做一些基础代码以及为自动化测试做基础，为了减少代码对其他部分的侵入性， 也采用了一些反射的机制。 其中碰到了不少有价值的细节，以及对于这个知识而言我们实战中通常要用到的一些东西， 而不是虚无缥缈的理论。我想总结出一篇文章以备自己以后查阅。
我觉的我这篇文章会含金量十足！

# 反射机制中我经常用到的问题模型以及扩展学习
根据以往的工作经验，我通常用到的不是反射初始化一个对象，或者生成一个动态代理啥的，我碰到的问题要比这种更抽象，以至于我做了n此总结，但是都没有彻底理解。我想先讲一些“高难度的”， 然后嘞一些十分基础的，后面带上， 反正一看就能懂的东西都是！

## 我遇到的问题

### 有关于拿当前对象上的泛型信息
事情起源
我自己封装网络库，理想的状况是希望用户这样调用。 如果用户觉得不是很好的话， 可以在这个基础上再次做个简单的封装， 作为工具类，毕竟不能做的过多，多做之错也很头疼的！

```java
Util.getInstance().asyncRequest(RequestBody, new MyRequestListerner<ResponseBean> () {
    @Override
    void onError(int errorCode, String errorDes) {
        // do something  这个是我底层用的http类，发生异常的时候会回调到这里
    }

    @Override
    void onResponse(ResponseBean responseBean, int code, String codeDes) {
        // do someThing 这个是回来结果了， 但是结果不一定是我们想要的， 
        //无论想不想要，我都会提供正确的 errorCode， 和一些详细解析， 那
        //么当用户判断code是成功的时候，直接可以拿responseBean来用就行，自己也不用解析了！
    }
})
```
其实乍一看代码还好是不是！觉得这都是理所当然的回调了。 但是实现的时候真的发现不是那么回事， 以至于我要写在文章里来总结这些深刻的教训！

背景是这样的， 对于上文中的```ResponseBean``` 而言， 这个家伙并不是真正的http响应体的所有内容， 而是这样的
```
"code" : "100000", // 假设服务端返回0代表正常
"codeDes" : "100000这个码的解释"
"data" : "" //data是当所有都正常的时候，服务端返回的真正内容，
// 当code不是0的时候就代表目前不正常，此时这个data是空的， 并且即使请求正确了， data有可能是一个jsonObject格式，也有可能仅仅是一个基础类型， 
所以data具有不确定性, 并且data才是我们正常逻辑里面真正关注的内容
```

而我要做的是，从原始的响应体里面扒出最初公共的属性值(code， codeDes)做处理，向用户吐出来， 并且在全部正常的情况下，将里面的data完全解析成用户给的泛型，再给用户吐出去。

我觉的，GSON的代码，是真的把抽象什么的玩的明明白白的！我真的想写一篇文章专门的解析一下这个源码。但是本篇不做过多描述。
在解析jsonString 并让他们映射成 Object上 GSON提供了一些很6的方法！我在解析上就是用的他们的
我们都知道， GSON有一些很常用的方法， 就是一系列的  fromGson()重载，现在我把他们列出来

![Snipaste_2022-01-26_11-16-03](/assets/Snipaste_2022-01-26_11-16-03.png)

这里的方法，我比较常用的是下面两个， 其中这次大量使用的是 fromJson(String, Type) 这个。讲真，之前没有深入研究，这次看见同事们用了我才知道有Type这么个东西。
<font color=red> 我的问题出在了，
1 我对Type不是很熟 
2 我当时不知道用什么方式能够拿到自己自定义的MyRequestListerner 这个上面的泛型，于是在核心处理阶段不知道拿着这些数据要处理成哪种bean！ </font>

好吧既然都写到这里了，我打算认认真真的将这些乱七八糟的梳理完！祝自己好运！

#### Type相关知识以及在Gson中的用法
##### Type
我们把之前画的族谱拿出来，看看，这个Type实际上是一个相当简单的东西

## 有关于基础数据类型在反射中，和包装类之间的区别以及解决方案
我碰到的是拿到某个类的方法之后，Method 获取参数列表的时候， 如果参数有 int boolean啥的，返回的就是基本类型 的 class.getName  而不是包装类的类名。 这些细节是不一样的。 如果你是根据配置来获取某个方法， 那么有点不幸的是，，哎！主要要配置正确！这两期写的代码太考究基本功了。

## 有关于拿静态相关的成员变量以及方法