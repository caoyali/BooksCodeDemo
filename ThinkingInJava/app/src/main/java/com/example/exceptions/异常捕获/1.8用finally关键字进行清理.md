[上一页：1.71特例-RuntimeException](/ThinkingInJava原版/异常捕获/1.71特例-RuntimeException.md)
# 1.8用finally关键字进行清理

##### finally关键字出现的硬核原因
有一个比较常见的场景：你希望碰到了try catch并且代码即使走到了catch里面，你也希望在最后执行一段代码。通常这个代码里做的事情是内存恢复亦或是引用清理！为了实现这个能力，Java为我们提供了 <font color=#FF7F50>finally闭包， 专门用在try catch语句的最后，来解决一些最后的执行问题</font>

##### finally关键字的使用方式

```
/**
 * 电子书  332页
 */
class ThreeException extends Exception {};

public class FinallyWorks {
    static int count = 0;

    public static void main(String[] args) {
        while (true) {
            try {
                if (count ++ == 0) {
                    throw new ThreeException();
                }
                System.out.println("No exception!");
            } catch (ThreeException e) {
                System.out.println("ThreeException");
            } finally {
                // finally 无论try块里面的逻辑是不是正常执行，都会执行这个闭包里面的代码！
                System.out.println("In finally clause");
                if (count == 2) break;
            }
        }
    }
}
```

##### 为什么要用finally?
一般在finally里面做一些清理的工作。或者是将已经用过的一些“资源”回归成最初的状态，比如 network connection.

```
public static void main(String[] args) {
        sw.on();
        try {
            f();
            sw.off();
        } catch (OnOffException1 onOffException1) {
            System.out.println("OnOffException1");
        } catch (OnOffException2 onOffException2) {
            System.out.println("OnOffException2");
        } finally {
            sw.off();
        }
    }
```

##### finally 也可以用在break和ontinue语句中

##### 在return中使用finally
finally是在无论什么情况下都能调用到的，但是有一点非常需要注意的是，这里面的代码可能会由不同的前置代码跳转过去，例如：正常情况下执行，最后到了finally， 和发生了异常，最后执行finally，，，这也就意味着，，你千万不要在里面写一些与业务强相关的代码。以避免出现一些低级错误。这里面的代码通常是一些清理工作，恢复工作。

**差点忘了讲重点，finally语句块，即使碰到了return，执行完后是依然会执行finally块中的代码的，不过前提你得知道用finally的合法“语境”**
- try catch 块
- brack， continue等关键字可以出现的地方，都可以出现finally语法。
```

/**
 * 电子书 336页
 */
public class MultipleReturns {
    public static void f(int i) {
        Print.print("Initialization that requires cleanup");
        try {
            Print.print("Point 1");
            if (i == 1) {
                return;
            }
            Print.print("Point 2");
            if (i == 2) {
                return;
            }
            Print.print("Point 3");
            if (i == 3) {
                Print.print("End");
                return;
            }
        } finally {
            // 从打印中是可以看出的，即使return了，最终依然会执行finally块中的代码
            Print.print("Performing cleanup");
        }
    }

    public static void main(String[] args) {
        for (int i = 1; i <= 4; i++) {
            f(i);
        }
    }
}
```



[下一页：1.9陷阱-丢失的Exception](/ThinkingInJava原版/异常捕获/1.9陷阱-丢失的Exception.md)