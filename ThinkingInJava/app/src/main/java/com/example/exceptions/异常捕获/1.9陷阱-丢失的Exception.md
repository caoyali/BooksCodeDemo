[上一页：1.8用finally关键字进行清理](/ThinkingInJava原版/异常捕获/1.8用finally关键字进行清理.md)

# 1.9陷阱-丢失的Exception

##### Java缺陷！在finally中的语句中，可能会导致Exception丢失

##### 缺陷丢失场景1：
代码袭来：
```
class VeryImportantException extends Exception {
    @Override
    public String toString() {
        return "A very important exception!";
    }
}

class HoHumException extends Exception {

}
public class LostMessage {
    void f() throws VeryImportantException {
        throw new VeryImportantException();
    }

    void dispose() throws HoHumException {
        throw new HoHumException();
    }

    public static void main(String[] args) {
        try {
          LostMessage im = new LostMessage();
          try {
              im.f();
          } finally {
              // 注意这里，如果外层嵌套的话，不进行catch，在语法上也是可以的！但是保不齐会出问题！
              // 比如在此种语句下，VeryImportantException是会被丢掉的！当然，以我的习惯，我可能不会写出这样的代码哈哈哈哈！
              im.dispose();
          }
        } catch (Exception e) {
            System.out.println(e);
        }
    }
}
```

打印结果是很让人出乎意料的！
只打印了HoHumException。丢异常了！用书中的解释，是异常被“覆盖”了！这种问题，相当不好抓！
##### 异常丢失场景2--在finally语句中return！
```
/**
 * 电子书 337页
 */
public class ExceptionSilencer {
    public static void main(String[] args) {
        try {
            throw new RuntimeException();
        } finally {
            return;
        }
    }
}
```
结果是什么都没有打印出来！

##### 解决方案
**<font color=#FF7F50>其实有一个最简单的方法来避免这类的问题，就是，切记写上try就一定要写catch。一定要承兑出现。这样就能解决了</font>**

[下一页： 1.91异常的限制条件](/ThinkingInJava原版/异常捕获/1.91异常的限制条件.md)