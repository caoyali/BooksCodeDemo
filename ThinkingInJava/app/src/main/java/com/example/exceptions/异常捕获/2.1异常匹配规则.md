[上一页：2.0构造器](/ThinkingInJava原版/异常捕获/2.0构造器.md)

# 异常匹配规则
当一个异常抛出去的时候，会按照书写代码的顺序由近及远进行一一匹配。
但是如果你的处理器中捕获的时候，出现声明捕获的是当前真实异常的父类的话，通常也是会被捕获到的！
对于异常的捕获顺序以及规则，大致有以下几点：

- try块中如果抛出了异常，你只能做出以下两种选择
  - 在try块后加上对应的捕获catch，这个catch一定要至少覆盖抛出的那个异常。
  - 如果你不想在try后面加catch的话，可以在方法的声明处加上throws，抛出去
- 异常处理器的异常处理匹配规则是，按照编码顺序，由上到下进行匹配,当前异常的父类也是可以匹配到的。所以尽量将父类的catch块往下写。
```
package com.example.exceptions;
// 烦恼，使人烦恼的事
class Annoyance extends Exception {

}

// 喷嚏
class Sneeze extends Annoyance {

}

public class Human {
    public static void main(String[] args) {
        try {
            throw new Sneeze();
        } catch (Sneeze s) {
            System.out.println("Caught Sneeze");
        } catch (Annoyance annoyance) {
            System.out.println("Caught Annoyance");
        }

        try {
            throw new Sneeze();
        } catch (Annoyance annoyance) {
            System.out.println("Caught Annoyance");
        } 
        // 如果父类在前面被捕获，此时，不管这个子类有多精准，多么匹配，都会
        // 在编译期时报错！原因是这样写的话，以下的代码肯定永远不会被走到，写也白写。
//        catch (Sneeze sneeze) {
//            System.out.println("");
//        }
    }
}
```

异常捕获可以接受当前所抛出异常的父类，这点也是有一些好处的，好处就是，当你在之后的需求里面创建新的子类的时候，不用更改任何代码。

#### 异常捕获需要注意的是
- 当你不知道出现异常的时候应该具体怎么处理的时候，请把它抛出去！
- 有时候你写了一个带异常的方法，那么调用者，会一层接着一层的写try，很是麻烦，但是这样做的好处是可以将所有的问题集中在一处进行处理。逻辑看起来简洁
- try catch的时候，那个catch块里，不要什么都不写，这样很不好！会导致看起来，“异常丢失！”。

#### java异常是自带检查的，但是有弊端
我们写代码的时候，就会发现一个事情，一般有调用一个抛出异常的方法，你要么去直接处理它，要么就是把它抛出去。然后谁调用谁处理。不这样写代码的话，java就会报错！这个初衷是好的。但是有弊端。正如只有java语言做了对异常的检查，其余的语言很少做这种限制的。
这个一个很大的弊端是，当项目越来越大，或者直接是大型工程的情况下，这种检查会让人十分头疼，写一堆看起来无用的代码，反而成了一种“拖油瓶”。任何东西都有两面性，不要磕着一个过度使用！