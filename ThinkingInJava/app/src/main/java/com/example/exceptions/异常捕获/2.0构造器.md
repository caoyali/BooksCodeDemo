[上一页： 1.91异常的限制条件](/ThinkingInJava原版/异常捕获/1.91异常的限制条件.md)

# 2.0构造器

#### 写带throws关键字的构造器是一个很愚蠢的行为
我想现实中很少有人去故意写一个带有throws关键字的构造器。这样写奇葩，也不太好！原因有：
构造器里面一旦向外部抛出异常很容易引发问题。例如假设在构造器里面打开了一些公共资源，然后里面发生了异常，你就抛出去。到了万一真的出现异常的时候，
- 首先，你这个对象肯定是创建失败了，你拿不到这个对象去做它有能力做的一些事情。
- 创建失败了，你的逻辑已经将一个文件打开了，在什么时候去关闭呢？异常已经出现了，接下来的代码就停止运行了。你直接将异常抛出去了，但是外界是没有办法获取这个对象，执行清理工作的！
- 那么此时你就想了，加一个finally怎么样，这样就能执行清理工作了。但是finnaly这个代码块是在任何情况下的最后都是可以执行的。难道你想写一堆蹩脚的判断代码来判断吗？

#### 但是如果你用到的类，其构构造器就是可以抛出一个异常，你应当怎么处理呢？
在调用的地方加上try catch。
```
package com.example.exceptions;

public class Cleanup {
    public static void main(String[] args) {
        try {
            InputFile inputFile = new InputFile("Cleanup.java");
            try {
                String s;
                int i = 1;
                while ((s = inputFile.getLine()) != null);
            } catch (Exception e) {
                System.out.println("Caught Exception in main!");
                e.printStackTrace();
            } finally {
                // dispose在这里调用，而不是在外面的那个catch里面调用。原因是，当InputFile()在初始化
                // 的时候发生异常，我们大可不必dispose，因为此时根本就没有开启资源！
                inputFile.dispose();
            }
        } catch (Exception e) {
//            new InputFile() 可能会引发异常，是在这里进行捕获的
            System.out.println("");
            e.printStackTrace();
        }
    }
}

```

[下一页：2.1异常的匹配规则](/ThinkingInJava原版/异常捕获/2.1异常匹配规则.md)